      SUBROUTINE new_ga4ind_N5(rtdb,d_v2,
     1                                kax_v2_alpha_offset,
     1                                size_2e)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     t ( p1 p2 h3 h4 )_t
      IMPLICIT NONE
#include "rtdb.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "stdio.fh"
#include "util.fh"
#include "bas.fh"
#include "schwarz.fh"
#include "sym.fh"
#include "sf.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
#include "n4ind_ps.fh"
c
c written by K. Kowalski
c
c
c     max. number of p2 groups =200
c
c
      integer rtdb                 ! Run-time database
      integer d_v2                 ! MO integrals
      integer kax_v2_alpha_offset  ! MO integrals offset
      integer size_2e              ! 2e file size
c
      INTEGER azone1,azone2,azone3,azone4
      INTEGER g1b,g2b,g3b,g4b
      INTEGER azone1_in,azone2_in,azone3_in,azone4_in
      integer g2b_in,g3b_in,g4b_in
      INTEGER igi1,igi2,igi3,igi4
      INTEGER ii,i,j,k,l,N,ipos1,ipos2,ipos3,ipos4
      INTEGER size_4a,l_4a,k_4a
      INTEGER size_aaaa
      INTEGER d_agaa,size_agaa,l_offset_agaa,k_offset_agaa
      INTEGER d_ggaa,size_ggaa,l_offset_ggaa,k_offset_ggaa
      integer d_ggaa_rep
      INTEGER d_ggga,size_ggga,l_offset_ggga,k_offset_ggga
      INTEGER l_loc_aaaa,k_loc_aaaa,size_loc_aaaa
      INTEGER l_loc_agaa,k_loc_agaa,size_loc_agaa
      INTEGER l_loc_ggaa,k_loc_ggaa,size_loc_ggaa
      INTEGER l_loc_ggga,k_loc_ggga,size_loc_ggga
      INTEGER l_loc_gggg,k_loc_gggg,size_loc_gggg
c
      integer key_aaaa,key_agaa,key_ggaa,key_ggga
      integer offset_aaaa,offset_agaa,offset_ggaa,offset_ggga
      integer key_gggg,offset_gggg
c
      integer max_size_temp,sumx
c
      integer tot_azone1_sh,tot_azone2_sh
      integer tot_azone3_sh,tot_azone4_sh
      integer tot_zone(1000)  !it was d.prec.
c
      integer iha,ihb !number of corr. alpha, beta holes
      integer ipa,ipb !number of corr. alpha, beta particles
c
      integer mu,nu,rho,sigma
      integer mu_lo,mu_hi
      integer nu_lo,nu_hi
      integer rho_lo,rho_hi
      integer sigma_lo,sigma_hi
      integer mu_range
      integer nu_range
      integer rho_range
      integer sigma_range
      integer mu1,nu1,rho1,sigma1
      integer shift_mu,shift_nu
      integer shift_rho,shift_sigma
      integer work1,work2          ! Work array sizes
      integer l_work1,k_work1      ! Work array 1
      integer l_work2,k_work2      ! Work array 2
      integer imu1,inu1,irho1,isigma1
c
      integer l_movecs_orb,k_movecs_orb
c
      integer l_integral,l_coeff
      integer k_integral,k_coeff
      integer l_aux,k_aux,size_aux
      integer l_aux2,k_aux2,size_aux2
      integer l_aux3,k_aux3,size_aux3
      integer istart
      integer size_ic,size_icc,size_integral,size_coeff,max_na
c
      integer INDEX_PAIR,icol,irow
c
ccx      double precision tot_zone(1000)
c 
      integer l_4af_offset,k_4af_offset,d_4af
      integer sf_chunk,request
      integer key_4af,offset_4af,size_4af
      character*255 filename
c 
      logical parallel
c
      INTEGER length
      INTEGER next
      INTEGER nprocs
      INTEGER count
      integer nnn, ilo,ihi,jlo,jhi
      integer nxtask
      external nxtask
      logical nodezero
      integer size_put
      integer k_4a_ptr
      integer ilo_put,ihi_put
      integer d4af_min,d4af_max
      logical idiskl
      integer mxsize_loc_aaaa,mxsize_loc_agaa
      integer mxsize_loc_ggga,mxsize_loc_ggaa
      integer mxsize_aux2,mxsize_aux3
      logical n4cache_found
      integer n4cache_newentry
      external n4cache_found,n4cache_newentry
      external tce_gacreatem_sloc
      logical tce_gacreatem_sloc,mirr4ind,n4cache2
c
c
      nodezero=(ga_nodeid().eq.0)
      call n4ind_pstat_init(rtdb)
c
c
      max_size_temp=imaxsize**4
c
      do ii=1,1000
       tot_zone(ii)=0.0d0
      enddo
      if(atpart.gt.1000)
     &  call errquit('tce_zones: atpart too big',1,MA_ERR)
      sumx=0
      do ii=1,atpart
       tot_zone(ii)=sumx
       sumx=sumx+nalength(ii)
      enddo
c
c
c this module is called only if intorb = .true.
c N is the number of correlated orbitals
        N = nmo(1) - nfc(1) - nfv(1)
        iha = nocc(1)-nfc(1)
        ihb = nocc(ipol)-nfc(ipol)
        ipa = nmo(1)-nocc(1)-nfv(1)
        ipb = nmo(ipol)-nocc(ipol)-nfv(ipol)
c
c     pre-compute size_loc_agaa & size_loc_aaaa
c
      mxsize_loc_agaa=0
      mxsize_loc_aaaa=0
      mxsize_aux2=0
      mxsize_aux3=0
      DO azone2 = 1,atpart
         DO azone1 = 1,azone2
            nnn=nalength(azone1)*nalength(azone2)
            DO g3b = 1,noa+nva
               DO azone3 = 1,atpart
                  mxsize_loc_agaa= max(mxsize_loc_agaa,
     V                 nnn*
     1                 nalength(azone3)*int_mb(k_range_alpha+g3b-1))

                  mxsize_aux2=max(mxsize_aux2,
     N                 nbf*nalength(azone3)*nalength(azone1)
     1                 *nalength(azone2))

                  DO azone4=1,atpart
                     mxsize_aux3=max(mxsize_aux3,
     N                    nalength(azone1)*nalength(azone2)*
     1                    nalength(azone3)*nalength(azone4))
                     
                     mxsize_loc_aaaa=max(mxsize_loc_aaaa,
     V                    nnn*
     1                    nalength(azone3)*nalength(azone4))
                  enddo
               enddo
            enddo
         enddo
      enddo
c     pre-compute size_loc_ggaa & size_loc_ggga
c
      mxsize_loc_ggaa=0
      mxsize_loc_ggga=0
      DO azone2 = 1,atpart
         DO g2b = 1,noa+nva
            DO g3b = 1,noa+nva
               DO g4b = g3b,noa+nva
                  mxsize_loc_ggga= max(mxsize_loc_ggga,
     N                 nalength(azone2)*int_mb(k_range_alpha+g2b-1)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1))

                  DO azone1=1,atpart ! azone1
                     mxsize_loc_ggaa=max(mxsize_loc_ggaa,
     N                    nalength(azone1)*nalength(azone2)*
     1  int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1))

                  enddo
               enddo
            enddo
         enddo
      enddo

      if (.not.rtdb_get(rtdb,'tce:mirr4n',mt_log,1,mirr4ind))
     A     mirr4ind=.false.
      if (.not.rtdb_get(rtdb,'tce:n4cache2',mt_log,1,n4cache2))
     A     n4cache2=.false.
c
c     Offset for 4a file
c
      sf_chunk=(imaxsize)**4
      call tce_4a_offset(l_4af_offset,k_4af_offset,size_4af)
c     open offset l_agaa
      call tce_offset_agaa(l_offset_agaa,k_offset_agaa,size_agaa)  
c     open offset l_ggaa
      call tce_offset_ggaa(l_offset_ggaa,k_offset_ggaa,size_ggaa)
c     open offset l_ggga
      call tce_offset_ggga(l_offset_ggga,k_offset_ggga,size_ggga)
      call tce_gacreate_sloc(d_4af, size_4af, 
     S     mxsize_loc_aaaa, 'd_4af')
ccx      call ga_zero(d_4af)

c
c alpha orbitals only
c
      if (.not.ma_push_get(mt_dbl,nbf*(iha+ipa)
     1  ,"sorted MO coeffs",
     2  l_movecs_orb,k_movecs_orb))
     3  call errquit('tce_mo2e_zone: MA problem 1',0,
     2    BASIS_ERR)
c      call dcopy(nbf*(iha+ipa),0.0d0, 0,dbl_mb(k_movecs_orb), 1)
      call dcopy(nbf*iha,
     c     dbl_mb(k_movecs_sorted),1,
     C     dbl_mb(k_movecs_orb),1)
      call dcopy(nbf*ipa,
     c     dbl_mb(k_movecs_sorted+(iha+ihb)*nbf),1,
     C     dbl_mb(k_movecs_orb+iha*nbf),1)
c
c
      call int_mem_2e4c(work1,work2)
      if (.not.ma_push_get(mt_dbl,work1,'work1',l_work1,k_work1))
     1  call errquit('tce_ao2e: MA problem work1',0,MA_ERR)
      if (.not.ma_push_get(mt_dbl,work2,'work2',l_work2,k_work2))
     1  call errquit('tce_ao2e: MA problem work2',1,MA_ERR)
c
c
c 
c 4af file formed here
c
c
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 0 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
      nprocs = GA_NNODES()
      count = 0
      call  ga_distribution(d_4af,ga_nodeid(),ilo,ihi,jlo,jhi)
cdbg      if(ga_nodeid().eq.0) write(6,*) ' size_loc_aaaa ',size_loc_aaaa,
cdbg     A ' size_4af ',size_4af
cdbg      write(6,4691) ga_nodeid(),' d_4af distr ',ilo,ihi,jlo,jhi
 4691 format(i6,a,4i16)
      if(jlo.gt.0) then
cold      next = NXTASK(nprocs, 1)
      DO azone1 = 1,atpart      !nu
      DO azone2 = azone1,atpart !mu
      DO azone3 = 1,atpart      !sigma
      DO azone4 = azone3,atpart !rho
         size_4a = nalength(azone1)*nalength(azone2)*
     1            nalength(azone3)*nalength(azone4)
         key_4af=azone4 - 1 + atpart * (azone3 - 1 +
     &          atpart * (azone2 - 1 + atpart * (azone1 - 1)))
        call tce_hash_n(int_mb(k_4af_offset),key_4af,offset_4af)
       if((ilo.le.offset_4af+size_4a).and.
     A      (ihi.ge.offset_4af+1)) then
cold      IF (next.eq.count) THEN
c ---------------------------
        if(.not.ma_push_get(mt_dbl,size_4a,'4a',l_4a,k_4a))
     1     call errquit('tce_4af_zones1: MA problem',0,MA_ERR)
        call dfill(size_4a, 0.0d0, dbl_mb(k_4a), 1)
         shift_mu = 0
         do mu    = a2length(azone2)+1,a2length(azone2+1)
            if (.not.bas_cn2bfr(ao_bas_han,mu,mu_lo,mu_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            mu_range = mu_hi - mu_lo + 1
         shift_nu = 0
         do nu    = a2length(azone1)+1,a2length(azone1+1)
            if (.not.bas_cn2bfr(ao_bas_han,nu,nu_lo,nu_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            nu_range = nu_hi - nu_lo + 1
         shift_rho = 0
         do rho   = a2length(azone4)+1,a2length(azone4+1)
            if (.not.bas_cn2bfr(ao_bas_han,rho,rho_lo,rho_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            rho_range = rho_hi - rho_lo + 1
         shift_sigma = 0
            if (on4indps) call pstat_on(ps_int2e0)
         do sigma = a2length(azone3)+1,a2length(azone3+1)
            if (.not.bas_cn2bfr(ao_bas_han,sigma,sigma_lo,sigma_hi))
     1      call errquit('tce_ao2e: basis fn range problem 1',0,
     2      BASIS_ERR)
            sigma_range = sigma_hi - sigma_lo + 1
            if (schwarz_shell(rho,sigma)*schwarz_shell(mu,nu)
     1          .ge. tol2e) then
            call int_2e4c(ao_bas_han,mu,nu,ao_bas_han,rho,sigma,
     1           work2,dbl_mb(k_work2),work1,dbl_mb(k_work1))
c
            call n4ind_transp(dbl_mb(k_4a),dbl_mb(k_work1),nalength,
     M           mu_range,nu_range,rho_range,sigma_range,
     S           shift_mu,shift_nu,shift_rho,shift_sigma,
     A           azone1,azone3,azone4)
            
            end if !schwarz  screening
         shift_sigma = shift_sigma + sigma_range
         enddo !sigma
          if (on4indps) call pstat_off(ps_int2e0)
         shift_rho   = shift_rho + rho_range
         enddo !rho
         shift_nu    = shift_nu + nu_range
         enddo !nu
         shift_mu    = shift_mu + mu_range
         enddo !mu
c
c fixing offsets and sf_writing
      if (on4indps) call pstat_on(ps_comm0)
cc      if(ga_nodeid().lt.2) write(6,4691) ga_nodeid(),' gaput0',
cc     A     offset_4af+1,offset_4af+size_4a,1,1
c avoid overlapping ga_put
      ilo_put=max(offset_4af+1,ilo)
      ihi_put=min(offset_4af+size_4a,ihi)
      size_put=ihi_put-ilo_put+1
      k_4a_ptr=k_4a+ilo_put-(offset_4af+1)
        call ga_put(d_4af,
     E     ilo_put,ihi_put,1,1,
     1    dbl_mb(k_4a_ptr),size_put)
      if (on4indps) call pstat_off(ps_comm0)
c closing l_4a file
        if (.not.ma_pop_stack(l_4a))
     1   call errquit('tcc_mo2e_4af2: l_4a',15,MA_ERR)
c ---------------------------
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !azone4
      ENDDO !azone3
      ENDDO !azone2
      ENDDO !azone1
      endif
c
cold      next = NXTASK(-nprocs, 1)
      if (on4indps) call pstat_on(ps_sync0)
      call ga_sync()
      if (on4indps) call pstat_off(ps_sync0)

      max_na=0
      do i=1,atpart
       if(nalength(i).gt.max_na) max_na=nalength(i)
      enddo
      size_icc=tile_dim*max_na
c
       if (.not.ma_push_get(mt_dbl,size_icc,'l_coeff',
     1  l_coeff,k_coeff))
     1  call errquit('tce_4s: MA problem l_coeff',0,MA_ERR)
c
c
c
c
c
c     step1
c
c     open ga d_agaa (size_agaa)
       d4af_min= int(1d10)
       d4af_max=-99999
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 1 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
       
      if (on4indps) call pstat_on(ps_comm1)
       call tce_gacreate_sloc(d_agaa, size_agaa,
     S     mxsize_loc_agaa, 'd_agaa')
      if (on4indps) call pstat_off(ps_comm1)

      call  ga_distribution(d_agaa,ga_nodeid(),ilo,ihi,jlo,jhi)
cdbg      write(6,4691) ga_nodeid(),' d_agaa distr ',ilo,ihi,jlo,jhi
      if(jlo.gt.0) then
       if (.not.ma_push_get(mt_dbl,mxsize_loc_agaa,'loc_agaa',
     1 l_loc_agaa,k_loc_agaa))
     1 call errquit('step1:1',mxsize_loc_agaa,MA_ERR)
        if (.not.ma_push_get(mt_dbl,mxsize_loc_aaaa,'loc_aaaa',
     1  l_loc_aaaa,k_loc_aaaa))
     1  call errquit('step1:2',mxsize_loc_aaaa,MA_ERR)
         if (.not.ma_push_get(mt_dbl,
     M   max(mxsize_loc_aaaa,mxsize_loc_agaa),'auxaaaa',
     1   l_aux,k_aux))
     1   call errquit('step1:3',mxsize_loc_agaa,MA_ERR)

      nprocs = GA_NNODES()
      count = 0
       if (.not.ma_push_get(mt_dbl,mxsize_aux2,'loc_qm2',
     1 l_aux2,k_aux2))
     1 call errquit('step2:1m4',0,MA_ERR)
       if (.not.ma_push_get(mt_dbl,
     M     max(mxsize_aux3,mxsize_loc_agaa),'loc_qm3',
     1 l_aux3,k_aux3))
     1 call errquit('Xtep2:1m4',0,MA_ERR)
      call n4cache_init()
       
cold      next = NXTASK(nprocs, 1)
c do parallel 
c      DO azone2 = 1,atpart
cstag to avoid congestion
      DO azone2_in = ga_nodeid(),ga_nodeid()+atpart-1
         azone2=mod(azone2_in,atpart)+1
      DO azone1_in = ga_nodeid(),ga_nodeid()+azone2-1
         azone1=mod(azone1_in,azone2)+1
      DO g3b_in = ga_nodeid(),ga_nodeid()+noa+nva-1
         g3b=mod(g3b_in,noa+nva)+1
      DO azone3_in = ga_nodeid(),ga_nodeid()+atpart-1
         azone3=mod(azone3_in,atpart)+1
       size_loc_agaa= nalength(azone1)*nalength(azone2)*
     1 nalength(azone3)*int_mb(k_range_alpha+g3b-1)
       key_agaa=azone3-1+atpart*(g3b-1+
     1  (noa+nva)*(azone1-1+atpart*(azone2-1)))
       call tce_hash_n(int_mb(k_offset_agaa),key_agaa,offset_agaa)
       if((ilo.le.offset_agaa+size_loc_agaa).and.
     A      (ihi.ge.offset_agaa+1)) then
cold      IF (next.eq.count) THEN
       call dfill(size_loc_agaa,0.0d0, dbl_mb(k_loc_agaa), 1)
c open k_aux (
c     declare (k_aux) ( all-az4 az3 | az1 az2)
      size_aux2=nbf*nalength(azone3)*nalength(azone1)
     1         *nalength(azone2)
      istart=0
c
       DO azone4=1,atpart
        size_aux3=nalength(azone1)*nalength(azone2)*
     1  nalength(azone3)*nalength(azone4)
        if(azone4.le.azone3) then ! azone4 <= azone3
         key_aaaa=azone3-1+atpart*(azone4-1+
     &          atpart*(azone2-1+atpart*(azone1-1)))
         call tce_hash_n(int_mb(k_4af_offset),key_aaaa,offset_aaaa)
c k_aux3: (az4 az3| az1 az2) -> (az2 az3|az1 az4)
      if (on4indps) call pstat_on(ps_get1)
cdbg      if(ga_nodeid().lt.2) write(6,4691) ga_nodeid(),' gaget11',
cdbg     1   offset_aaaa+1,offset_aaaa+size_aux3,1,1
      d4af_min=min(d4af_min,offset_aaaa+1)
      d4af_max=max(d4af_max,offset_aaaa+size_aux3)
      call n4cache_get4af(offset_aaaa+1,offset_aaaa+size_aux3,
     D     d_4af,dbl_mb(k_aux3))

      if (on4indps) call pstat_off(ps_get1)
c transposition (az4 az3|az1 az2) --> (az2 az3|az1 az4)
        call TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_aux2+istart),
     1   nalength(azone4),nalength(azone3),
     1   nalength(azone1),nalength(azone2),4,2,3,1,1.0d0)
        istart=istart+size_aux3
        else    ! azone4 > azone3
         key_aaaa=azone4-1+atpart*(azone3-1+
     &          atpart*(azone2-1+atpart*(azone1-1)))
         call tce_hash_n(int_mb(k_4af_offset),key_aaaa,offset_aaaa)
      if (on4indps) call pstat_on(ps_get1)
cdbg      if(ga_nodeid().lt.2) write(6,4691) ga_nodeid(),' gaget12',
cdbg     1    offset_aaaa+1,offset_aaaa+size_aux3,1,1
      d4af_min=min(d4af_min,offset_aaaa+1)
      d4af_max=max(d4af_max,offset_aaaa+size_aux3)
#if 0
         call ga_get(d_4af,offset_aaaa+1,offset_aaaa+size_aux3,1,1,
     1    dbl_mb(k_aux3),size_aux3)
#else
      call n4cache_get4af(offset_aaaa+1,offset_aaaa+size_aux3,
     D     d_4af,dbl_mb(k_aux3))
#endif
      if (on4indps) call pstat_off(ps_get1)
c        k_aux3: (az3 az4|az1 az2) -> (az2 az3|az1 az4)
        call TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_aux2+istart),
     1   nalength(azone3),nalength(azone4),
     1   nalength(azone1),nalength(azone2),4,1,3,2,1.0d0)
        istart=istart+size_aux3
        end if  ! azone4 <= azone3
       ENDDO  !azone4
c big dgemm here (az2 az3|az1 all-az4)(all-az4 g3)=(az2 az3|az1 g3)
      if (on4indps) call pstat_on(ps_comp1)
       call dgemm('N','N',
     1  nalength(azone2)*nalength(azone3)*nalength(azone1),
     2  int_mb(k_range_alpha+g3b-1),
     3  nbf,
     4  1.0d0,
     5  dbl_mb(k_aux2),
     1  nalength(azone2)*nalength(azone3)*nalength(azone1),
     7  dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g3b-1)*nbf),
     8  nbf,0.0d0,
     9  dbl_mb(k_aux3),
     1  nalength(azone2)*nalength(azone3)*nalength(azone1))
      if (on4indps) call pstat_off(ps_comp1)
c TRANSPOSITION
       CALL TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_loc_agaa),
     &  nalength(azone2),nalength(azone3),
     &  nalength(azone1),int_mb(k_range_alpha+g3b-1),
     &  2,4,3,1,1.0d0)
      if (on4indps) call pstat_on(ps_put1)
cdbg      if(ga_nodeid().lt.2) write(6,4691) ga_nodeid(),' gaput1',
cdbg     1    offset_agaa+1,offset_agaa+size_loc_agaa,1,1
       call ga_put(d_agaa,offset_agaa+1,offset_agaa+size_loc_agaa,1,1,
     1  dbl_mb(k_loc_agaa),size_loc_agaa)
      if (on4indps) call pstat_off(ps_put1)
c
c
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !azone3
      ENDDO !g3b
      ENDDO !azone1
      ENDDO !azone2
      call n4cache_stop()
        if (.not.ma_pop_stack(l_aux3))
     1  call errquit('f4ind:QA1',15,MA_ERR)
        if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4ind:QA1',15,MA_ERR)
        if (.not.ma_pop_stack(l_aux))
     1  call errquit('g4ind:MA1',15,MA_ERR)
        if (.not.ma_pop_stack(l_loc_aaaa))
     1  call errquit('g4ind:MA1',15,MA_ERR)
       if (.not.ma_pop_stack(l_loc_agaa))
     1 call errquit('g4ind:MA1',15,MA_ERR)
cold      next = NXTASK(-nprocs, 1)
      endif
      if (on4indps) call pstat_on(ps_comm1)
cedo      call ga_sync()      
c     delete d_4af
cdbg      write(6,1973) ga_nodeid(), ' d4af min max ',d4af_min,d4af_max,
cdbg     C     d4af_max-d4af_min+1
 1973 format(i6,a,3i20)
      call deletefile(d_4af)
      if (on4indps) call pstat_off(ps_comm1)
c
c
c
c
c
c
c
c     step2
c
c     open ga d_ggaa (size_ggaa)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 2 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
      if (on4indps) call pstat_on(ps_comm2)
      call tce_gacreate_sloc(d_ggaa, size_ggaa,
     S     mxsize_loc_ggaa, 'd_ggaa')
      if (on4indps) call pstat_off(ps_comm2)
c
      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
      call  ga_distribution(d_ggaa,ga_nodeid(),ilo,ihi,jlo,jhi)
      if(jlo.gt.0) then
c do parallel
      DO azone2 = 1,atpart
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
cold      IF (next.eq.count) THEN
       key_ggaa=g4b-1+(noa+nva)*(g3b-1+
     &  (noa+nva)*(azone1-1+atpart*(azone2-1)))
       call tce_hash_n(int_mb(k_offset_ggaa),key_ggaa,offset_ggaa)
       size_loc_ggaa= nalength(azone1)*nalength(azone2)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
       if((ilo.le.offset_ggaa+size_loc_ggaa).and.
     A      (ihi.ge.offset_ggaa+1)) then
       if (.not.ma_push_get(mt_dbl,size_loc_ggaa,'loc_ggaa',
     1 l_loc_ggaa,k_loc_ggaa))
     1 call errquit('step2:1',0,MA_ERR)
      call dfill(size_loc_ggaa,0.0d0, dbl_mb(k_loc_ggaa), 1)
c
c     declare (k_aux) ( nbf(az3) g3b | az1 az2)
      size_aux=nbf*int_mb(k_range_alpha+g3b-1)*nalength(azone1)
     1         *nalength(azone2)
       if (.not.ma_push_get(mt_dbl,size_aux,'loc_all-a-gaa',
     1 l_aux,k_aux))
     1 call errquit('step2:1m4',0,MA_ERR)
      istart=0
c
       DO azone3=1,atpart
        size_loc_agaa=nalength(azone1)*nalength(azone2)*
     1  int_mb(k_range_alpha+g3b-1)*nalength(azone3)
        key_agaa=azone3-1+atpart*(g3b-1+
     1   (noa+nva)*(azone1-1+atpart*(azone2-1)))
        call tce_hash_n(int_mb(k_offset_agaa),key_agaa,offset_agaa)
       if (.not.ma_push_get(mt_dbl,size_loc_agaa,'loc_agaa',
     1  l_aux2,k_aux2))
     1  call errquit('step2:1m4uu',0,MA_ERR)
      if (on4indps) call pstat_on(ps_comm2)
        call ga_get(d_agaa,offset_agaa+1,offset_agaa+size_loc_agaa,1,1,
     1   dbl_mb(k_aux2),size_loc_agaa)
      if (on4indps) call pstat_off(ps_comm2)
        call TCE_SORT_4KG_(dbl_mb(k_aux2),dbl_mb(k_aux+istart),
     1   nalength(azone3),int_mb(k_range_alpha+g3b-1),
     1   nalength(azone1),nalength(azone2),4,2,3,1,1.0d0)
        istart=istart+size_loc_agaa
        if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4ind:MA1xo',16,MA_ERR)
c stored as (az2 g3b az1 all-az3)
c
       ENDDO
c 
c   do global dgemm (az2 g3b az1 all-az3) C(all-az3 g4) => 
c      (az2 g3b az1 g4)
c
       if (.not.ma_push_get(mt_dbl,size_loc_ggaa,'aux2',
     1  l_aux2,k_aux2))
     1 call errquit('step2:1m4z5',0,MA_ERR)
c
      if (on4indps) call pstat_on(ps_comp2)
       call dgemm('N','N',
     1  nalength(azone2)*int_mb(k_range_alpha+g3b-1)*nalength(azone1),
     2  int_mb(k_range_alpha+g4b-1),
     3  nbf,
     4  1.0d0,
     5  dbl_mb(k_aux),
     6  nalength(azone2)*int_mb(k_range_alpha+g3b-1)*nalength(azone1),
     7  dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g4b-1)*nbf),
     8  nbf,0.0d0,
     9  dbl_mb(k_aux2),
     1  nalength(azone2)*int_mb(k_range_alpha+g3b-1)*nalength(azone1))
      if (on4indps) call pstat_off(ps_comp2)
c
        call TCE_SORT_4KG_(dbl_mb(k_aux2),dbl_mb(k_loc_ggaa),
     1   nalength(azone2),int_mb(k_range_alpha+g3b-1),
     1   nalength(azone1),int_mb(k_range_alpha+g4b-1),
     1   4,2,3,1,1.0d0)
c
        if (.not.ma_pop_stack(l_aux2))
     1  call errquit('g4ind:MA1x9',16,MA_ERR)
c
c   delete k_aux
       if (.not.ma_pop_stack(l_aux))
     1 call errquit('g4ind:MAu3',15,MA_ERR)
c     
      if (on4indps) call pstat_on(ps_comm2)
       call ga_put(d_ggaa,offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1,
     1  dbl_mb(k_loc_ggaa),size_loc_ggaa)
      if (on4indps) call pstat_off(ps_comm2)
       if (.not.ma_pop_stack(l_loc_ggaa))
     1 call errquit('g4ind:MA1',15,MA_ERR)
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !g4b
      ENDDO !g3b
      ENDDO !azone1
      ENDDO !azone2
cold      next = NXTASK(-nprocs, 1)
      endif
      if (on4indps) call pstat_on(ps_comm2)
cedo      call ga_sync()
      if (on4indps) call pstat_off(ps_comm2)
c     delete d_agaa
      call deletefile(d_agaa)
c
c
c
c
c
c
c
c
c     step3
c
c     open ga d_ggga (size_ggga)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 3 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif

      if (on4indps) call pstat_on(ps_comm3)
      if(mirr4ind) then
cmirr to ease ga_get on d_ggaa
         if(tce_gacreatem_sloc(d_ggaa_rep, size_ggaa,
     S        mxsize_loc_ggaa, 'd_ggaa')) then
            call ga_mask_sync(.true.,.false.)
            call ga_copy(d_ggaa,d_ggaa_rep)
            call ga_mask_sync(.true.,.false.)
            call deletefile(d_ggaa)
            d_ggaa=d_ggaa_rep
         endif
      endif


      call tce_gacreate_sloc(d_ggga, size_ggga,
     S     mxsize_loc_ggga, 'd_ggga')
      if (on4indps) call pstat_off(ps_comm3)
c
       d4af_min= int(1d10)
       d4af_max=-99999
      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
      call  ga_distribution(d_ggga,ga_nodeid(),ilo,ihi,jlo,jhi)
#ifdef DBG
          write(6,'(A,I3,A,I9,A,I9,A,I9,A,I9)') 
     M         ' me ',ga_nodeid(),' ilo ',ilo,' ihi ',ihi,
     A         ' jlo ',jlo,' jhi ',jhi          
          call util_flush(6)
#endif
      if(jlo.gt.0) then
      if (.not.ma_push_get(mt_dbl,mxsize_loc_ggga,'loc_qyaa',
     1     l_aux,k_aux))
     1     call errquit('step3:1ma',0,MA_ERR)
      if (.not.ma_push_get(mt_dbl,mxsize_aux2,'loc_all-a-gaa',
     1 l_aux2,k_aux2))
     1 call errquit('step2:1m4',0,MA_ERR)
c open k_aux3
         if (.not.ma_push_get(mt_dbl,mxsize_loc_ggaa,'auxaaaa',
     1   l_aux3,k_aux3))
     1   call errquit('step3:3',0,MA_ERR)
       if (.not.ma_push_get(mt_dbl,mxsize_loc_ggga,'loc_ggga',
     1 l_loc_ggga,k_loc_ggga))
     1 call errquit('step3:1',0,MA_ERR)

      if(n4cache2)call n4cache_init()

c do parallel
#if 0
      DO azone2 = 1,atpart
      DO g2b = 1,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
#else
      DO azone2_in = ga_nodeid(),ga_nodeid()+atpart-1
         azone2=mod(azone2_in,atpart)+1
      DO g2b_in = ga_nodeid(),ga_nodeid()+noa+nva-1
         g2b=mod(g2b_in,noa+nva)+1
      DO g3b_in = ga_nodeid(),ga_nodeid()+noa+nva-1
         g3b=mod(g3b_in,noa+nva)+1
      DO g4b_in = ga_nodeid(),ga_nodeid()+noa+nva-g3b
         g4b=mod(g4b_in,noa+nva-g3b+1)+g3b
#endif
cold      IF (next.eq.count) THEN
       size_loc_ggga= nalength(azone2)*int_mb(k_range_alpha+g2b-1)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
       key_ggga=g4b-1+(noa+nva)*(g3b-1+
     &  (noa+nva)*(g2b-1+(noa+nva)*(azone2-1)))
       call tce_hash_n(int_mb(k_offset_ggga),key_ggga,offset_ggga)
c     do only if ilo <= offset_ggga+size_loc_ggga & ihi>=offset_ggga+1
       if((ilo.le.offset_ggga+size_loc_ggga).and.
     A      (ihi.ge.offset_ggga+1)) then
#ifdef DBG
          write(6,'(A,I3,A,I9,A,I9,A,I9,A,I9)') 
     M         ' me ',ga_nodeid(),' ilo ',ilo,' ihi ',ihi,
     A         ' olo ',offset_ggga+1,' ohi ',offset_ggga+size_loc_ggga
          call util_flush(6)
#endif
       call dfill(size_loc_ggga,0.0d0, dbl_mb(k_loc_ggga), 1)
c     declare (k_aux) ( g4 g3 |  az2 all-az1)
      size_aux2=int_mb(k_range_alpha+g4b-1)*
     1         int_mb(k_range_alpha+g3b-1)*
     1         nalength(azone2)*
     1         nbf
      istart=0
c
#if 1
       DO azone1=1,atpart ! azone1
#else
       DO azone1_in=ga_nodeid(),ga_nodeid()+atpart-1 ! azone1
          azone1=mod(azone1_in,atpart)+1
#endif
        if(azone2.le.azone1) then ! azone2 <= azone1
         size_loc_ggaa= nalength(azone1)*nalength(azone2)*
     1   int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
         key_ggaa=g4b-1+(noa+nva)*(g3b-1+
     &   (noa+nva)*(azone2-1+atpart*(azone1-1)))
         call tce_hash_n(int_mb(k_offset_ggaa),key_ggaa,offset_ggaa)
      if (on4indps) call pstat_on(ps_get3)
c      if(ga_nodeid().lt.2) write(6,4691) ga_nodeid(),' gaget31',
c     c     offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1
      d4af_min=min(d4af_min,offset_ggaa+1)
      d4af_max=max(d4af_max,offset_ggaa+size_loc_ggaa)
      if(n4cache2) then
         call n4cache_get4af(offset_ggaa+1,offset_ggaa+size_loc_ggaa,
     D     d_ggaa,dbl_mb(k_aux2+istart))
      else
         call ga_get(d_ggaa,offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1,
     1   dbl_mb(k_aux2+istart),size_loc_ggaa)
      endif
         istart=istart+size_loc_ggaa
      if (on4indps) call pstat_off(ps_get3)
c k_aux accumulates (g4 g3 |az2 az1)
        else ! azone2 <= azone1
         size_loc_ggaa= nalength(azone1)*nalength(azone2)*
     1   int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
         key_ggaa=g4b-1+(noa+nva)*(g3b-1+
     &   (noa+nva)*(azone1-1+atpart*(azone2-1)))
         call tce_hash_n(int_mb(k_offset_ggaa),key_ggaa,offset_ggaa)
      if (on4indps) call pstat_on(ps_get3)
c      if(ga_nodeid().lt.2) write(6,4691) ga_nodeid(),' gaget32',
c     c     offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1
      d4af_min=min(d4af_min,offset_ggaa+1)
      d4af_max=max(d4af_max,offset_ggaa+size_loc_ggaa)
      if(n4cache2) then
         call n4cache_get4af(offset_ggaa+1,offset_ggaa+size_loc_ggaa,
     D     d_ggaa,dbl_mb(k_aux3))
      else
         call ga_get(d_ggaa,offset_ggaa+1,offset_ggaa+size_loc_ggaa,1,1,
     1   dbl_mb(k_aux3),size_loc_ggaa)
      endif
      if (on4indps) call pstat_off(ps_get3)
c k_aux3: (g4 g3|az1 az2) => (g4 g3|az2 az1-all)
         CALL TCE_SORT_4KG_(dbl_mb(k_aux3),dbl_mb(k_aux2+istart),
     &   int_mb(k_range_alpha+g4b-1),int_mb(k_range_alpha+g3b-1),
     &   nalength(azone1),nalength(azone2),
     &   1,2,4,3,1.0d0)
         istart=istart+size_loc_ggaa
c 
        end if ! azone2 <= azone1
       ENDDO ! azone1
c ([g4]=>[g3]|[azone2]all-azone1])*C_(all-azone1[g2])
c
      if (on4indps) call pstat_on(ps_comp3)
         call dgemm('N','N',
     1   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     1   nalength(azone2),                                        !m
     1   int_mb(k_range_alpha+g2b-1),                             !n
     3   nbf,                                                     !k
     4   1.0d0,dbl_mb(k_aux2),
     5   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     5   nalength(azone2),
     6   dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g2b-1)*nbf),nbf,
     7   0.0d0,dbl_mb(k_aux),
     8   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     8   nalength(azone2))
      if (on4indps) call pstat_off(ps_comp3)
C TRANSPOSITION HERE (g4=>g3|az2 g2) => (g4=>g3|g2 az2)
       CALL TCE_SORT_4KG_(dbl_mb(k_aux),dbl_mb(k_loc_ggga),
     & int_mb(k_range_alpha+g4b-1),int_mb(k_range_alpha+g3b-1),
     & nalength(azone2),int_mb(k_range_alpha+g2b-1),
     & 1,2,4,3,1.0d0)
      if (on4indps) call pstat_on(ps_put3)
       call ga_put(d_ggga,offset_ggga+1,offset_ggga+size_loc_ggga,1,1,
     1  dbl_mb(k_loc_ggga),size_loc_ggga)
      if (on4indps) call pstat_off(ps_put3)
c
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      ENDDO !g4b
      ENDDO !g3b
      ENDDO !g2b
      ENDDO !azone2
      if(n4cache2) call n4cache_stop()
      if (.not.ma_pop_stack(l_loc_ggga))
     1     call errquit('g4ind:MA1',15,MA_ERR)
      if (.not.ma_pop_stack(l_aux3))
     1     call errquit('g4Znd:MA1',15,MA_ERR)
      if (.not.ma_pop_stack(l_aux2))
     1     call errquit('g4Pnd:MA1',15,MA_ERR)
      if (.not.ma_pop_stack(l_aux))
     1     call errquit('g4ind:MA1',15,MA_ERR)
      endif
cood      next = NXTASK(-nprocs, 1)
      if (on4indps) call pstat_on(ps_sync3)
cedo      call ga_sync()
c     delete d_ggaa
cdbg      write(6,1973) ga_nodeid(), ' gets min max ',d4af_min,d4af_max,
cdbg     C     d4af_max-d4af_min+1
      call deletefile(d_ggaa)
      if (on4indps) call pstat_off(ps_sync3)
       if(nodezero) then
          write(6,'(A,F20.2,A)') ' starting step 4 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
c
c
c
c
c
c
c
c
c
c
c     step4
c
      call  ga_distribution(d_v2,ga_nodeid(),ilo,ihi,jlo,jhi)
      nprocs = GA_NNODES()
      count = 0
cold      next = NXTASK(nprocs, 1)
c do parallel
      if(jlo.gt.0) then
      DO g1b = 1,noa+nva
      DO g2b = g1b,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
c
       IF (int_mb(k_spin_alpha+g3b-1)+int_mb(k_spin_alpha+g4b-1).eq.
     & int_mb(k_spin_alpha+g1b-1)+int_mb(k_spin_alpha+g2b-1)) THEN
       IF (ieor(int_mb(k_sym_alpha+g3b-1),ieor(int_mb(k_sym_alpha+g4b-1)
     & ,ieor(int_mb(k_sym_alpha+g1b-1),int_mb(k_sym_alpha+g2b-1)))) .eq.
     & irrep_v) THEN
       IROW=INDEX_PAIR(g4b,g3b)
       ICOL=INDEX_PAIR(g2b,g1b)
       IF(IROW.GE.ICOL) THEN
c
       size_loc_gggg= int_mb(k_range_alpha+g1b-1)*
     1 int_mb(k_range_alpha+g2b-1)*
     1 int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
       key_gggg=g2b - 1 + (noa+nva) *
     &(g1b - 1 + (noa+nva) * (g4b-
     & 1 + (noa+nva) * (g3b - 1)))
       call tce_hash_v2(int_mb(k_v2_alpha_offset),key_gggg,offset_gggg)
       if((ilo.le.offset_gggg+size_loc_gggg).and.
     A      (ihi.ge.offset_gggg+1)) then
cold      IF (next.eq.count) THEN
       if (.not.ma_push_get(mt_dbl,size_loc_gggg,'loc_gggg',
     1 l_loc_gggg,k_loc_gggg))
     1 call errquit('step4:1',0,MA_ERR)
      call dfill(size_loc_gggg,0.0d0, dbl_mb(k_loc_gggg), 1)
c k_aux2: (g4 g3| g2 all-az2)
      size_aux2=int_mb(k_range_alpha+g4b-1)*
     1         int_mb(k_range_alpha+g3b-1)*
     1         int_mb(k_range_alpha+g2b-1)*
     1         nbf
      if (.not.ma_push_get(mt_dbl,size_aux2,'loc_all-a-gaa',
     1 l_aux2,k_aux2))
     1 call errquit('step4:1m4',0,MA_ERR)
      istart=0
       DO azone2=1,atpart
        size_loc_ggga=nalength(azone2)*int_mb(k_range_alpha+g2b-1)*
     1  int_mb(k_range_alpha+g3b-1)*int_mb(k_range_alpha+g4b-1)
        key_ggga=g4b-1+(noa+nva)*(g3b-1+
     &  (noa+nva)*(g2b-1+(noa+nva)*(azone2-1)))
        call tce_hash_n(int_mb(k_offset_ggga),key_ggga,offset_ggga)
      if (on4indps) call pstat_on(ps_comm4)
        call ga_get(d_ggga,offset_ggga+1,offset_ggga+size_loc_ggga,1,1,
     1   dbl_mb(k_aux2+istart),size_loc_ggga)
      if (on4indps) call pstat_off(ps_comm4)
        istart=istart+size_loc_ggga
c
       ENDDO !azone2
c
      if (on4indps) call pstat_on(ps_comm4)
        call dgemm('N','N',
     1   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     1   int_mb(k_range_alpha+g2b-1),                             !m
     1   int_mb(k_range_alpha+g1b-1),                             !n
     3   nbf,                                                     !k
     4   1.0d0,dbl_mb(k_aux2),
     5   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     5   int_mb(k_range_alpha+g2b-1),
     6   dbl_mb(k_movecs_orb+int_mb(k_offset_alpha+g1b-1)*nbf),
     7   nbf,
     7   0.0d0,dbl_mb(k_loc_gggg),
     8   int_mb(k_range_alpha+g4b-1)*int_mb(k_range_alpha+g3b-1)*
     8   int_mb(k_range_alpha+g2b-1))
      if (on4indps) call pstat_off(ps_comm4)
c
      if (on4indps) call pstat_on(ps_comm4)
       call ga_put(d_v2,offset_gggg+1,offset_gggg+size_loc_gggg,1,1,
     1  dbl_mb(k_loc_gggg),size_loc_gggg)
      if (on4indps) call pstat_off(ps_comm4)

       if (.not.ma_pop_stack(l_aux2))
     1 call errquit('g4ppq:MA1',15,MA_ERR)
       if (.not.ma_pop_stack(l_loc_gggg))
     1 call errquit('g4ind:MA1',15,MA_ERR)
cold      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
       END IF
       END IF
       END IF
      ENDDO !g4b
      ENDDO !g3b
      ENDDO !g2b
      ENDDO !g1b
cold      next = NXTASK(-nprocs, 1)
      endif
      if (on4indps) call pstat_on(ps_comm4)
cedo      call ga_sync()
      if (on4indps) call pstat_off(ps_comm4)
c     delete d_ggga
      call deletefile(d_ggga)

       if(nodezero) then
          write(6,'(A,F20.2,A)') ' done step 4 at ',
     C         util_wallsec(), ' secs '
          call util_flush(6)
       endif
c
c
c
c
c     delete l_coeff 
      if (.not.ma_pop_stack(l_coeff))
     1  call errquit('tcc_off_4a: MA problem',15,MA_ERR)
c
      if (.not.ma_pop_stack(l_work2))
     1  call errquit('tcc_ao2e: MA problem',14,MA_ERR)
c
      if (.not.ma_pop_stack(l_work1))
     1  call errquit('tcc_ao2e: MA problem',15,MA_ERR)
c
      if (.not.ma_pop_stack(l_movecs_orb))
     1  call errquit('tcc_ao2e: MA problem',15,MA_ERR)
c     delete l_ggga
      if (.not.ma_pop_stack(l_offset_ggga)) then
          call ma_summarize_allocated_blocks()
         call errquit('ga4ind:ggga',15,MA_ERR)
      endif
c     delete l_ggaa
      if (.not.ma_pop_stack(l_offset_ggaa))
     1  call errquit('ga4ind:ggaa',15,MA_ERR)
c     delete l_agaa    
      if (.not.ma_pop_stack(l_offset_agaa))
     1  call errquit('ga4ind:agaa',15,MA_ERR)
c
      if (.not.ma_pop_stack(l_4af_offset))
     1  call errquit('ga4ind:4a',15,MA_ERR)
c
c
      call n4ind_pstat_print()
      RETURN
      END
c
c
c
c
c
c
c
c
      SUBROUTINE tce_offset_agaa(l_a_offset,k_a_offset,size)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER g3b,azone1,azone2,azone3
c ([az3],[g3]|[az1]<=[az2])
      length = 0
      DO azone2 = 1,atpart      
      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO azone3 = 1,atpart
      length = length + 1
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('tce_t2_offset',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO azone2 = 1,atpart      
      DO azone1 = 1,azone2 
      DO g3b = 1,noa+nva
      DO azone3 = 1,atpart
      addr = addr + 1
      int_mb(k_a_offset+addr) = azone3 - 1 + atpart * (g3b - 1 +
     &  (noa+nva) * (azone1 - 1 + atpart * (azone2 - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + nalength(azone2) * nalength(azone1) *
     &  int_mb(k_range_alpha+g3b-1) * nalength(azone3)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
c
c
c
      SUBROUTINE tce_offset_ggaa(l_a_offset,k_a_offset,size)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER g3b,g4b,azone1,azone2
c ([g4]=>[g3]|[az1]<=[az2])
      length = 0
      DO azone2 = 1,atpart
cmoved to innermost      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      DO azone1 = 1,azone2
      length = length + 1
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('tce_t2_offset',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO azone2 = 1,atpart
cmoved to innermost      DO azone1 = 1,azone2
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      DO azone1 = 1,azone2
      addr = addr + 1
      int_mb(k_a_offset+addr) = g4b - 1 + (noa+nva) * (g3b - 1 +
     &  (noa+nva) * (azone1 - 1 + atpart * (azone2 - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + nalength(azone2) * nalength(azone1) *
     &  int_mb(k_range_alpha+g3b-1) * int_mb(k_range_alpha+g4b-1)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
c
c
c
      SUBROUTINE tce_offset_ggga(l_a_offset,k_a_offset,size)
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
#include "tce_main.fh"
      INTEGER l_a_offset
      INTEGER k_a_offset
      INTEGER size
      INTEGER length
      INTEGER addr
      INTEGER g3b,g4b,g2b,azone2
c ([g4]=>[g3]|[g2][az2])
      length = 0
      DO azone2 = 1,atpart
      DO g2b = 1,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      length = length + 1
      END DO
      END DO
      END DO
      END DO
      IF (.not.MA_PUSH_GET(mt_int,2*length+1,'noname',l_a_offset,k_a_off
     &set)) CALL ERRQUIT('tce_t2_offset',0,MA_ERR)
      int_mb(k_a_offset) = length
      addr = 0
      size = 0
      DO azone2 = 1,atpart
      DO g2b = 1,noa+nva
      DO g3b = 1,noa+nva
      DO g4b = g3b,noa+nva
      addr = addr + 1
      int_mb(k_a_offset+addr) = g4b - 1 + (noa+nva) * (g3b - 1 +
     &  (noa+nva) * (g2b - 1 + (noa+nva) * (azone2 - 1)))
      int_mb(k_a_offset+length+addr) = size
      size = size + nalength(azone2) * int_mb(k_range_alpha+g2b-1) *
     &  int_mb(k_range_alpha+g3b-1) * int_mb(k_range_alpha+g4b-1)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END
      subroutine tce_gacreate_sloc(g_a, size, size_loc, gname)
      implicit none
#include "global.fh"
#include "mafdecls.fh"
#include "errquit.fh"
#include "stdio.fh"
      integer g_a
      character*(*) gname
      integer size
      integer size_loc
c
         call ga_mask_sync(.true.,.false.)
      if (.not.ga_create(mt_dbl,size,1,gname,
     1     size_loc,1,g_a)) then
         write(LuOut,*) ' available GA memory ',
     1        ga_memory_avail(),' bytes'
         call errquit ('tce_gacreate: failed ga_create size/nproc bytes'
     S      ,   (size*ma_sizeof(mt_dbl,1,mt_byte))/ga_nnodes(),
     1        GA_ERR)
      endif
c      call ga_zero(g_a)
      return
      end
      logical function tce_gacreatem_sloc(g_amirr, 
     S     size, size_loc, gname)
      implicit none
#include "global.fh"
#include "mafdecls.fh"
#include "errquit.fh"
#include "stdio.fh"
      integer g_amirr
      character*(*) gname
      integer size
      integer size_loc
c
      integer dims(2),gnblock(2),plist
c
      gnblock(1)=size_loc
      gnblock(2)=1
      dims(1)=size
      dims(2)=1
      plist=ga_pgroup_get_mirror()
      
      tce_gacreatem_sloc=.true.
         call ga_mask_sync(.true.,.false.)
      if (.not.nga_create_config(mt_dbl, 2, dims, gname,
     1     gnblock, plist, g_amirr)) then
         write(LuOut,*) ' failed gamirr: available GA memory ',
     1        ga_memory_avail(),' bytes'
         tce_gacreatem_sloc=.false.
c         call errquit ('tce_gacreatem: failed ga_create '
c     S      ,   (size*ma_sizeof(mt_dbl,1,mt_byte))/ga_nnodes(),
c     1        GA_ERR)
      else
         call ga_mask_sync(.true.,.false.)
         call ga_zero(g_amirr)
      endif
      return
      end
      subroutine n4ind_pstat_init(rtdb)
      implicit none
#include "pstat.fh"
#include "rtdb.fh"
#include "mafdecls.fh"
#include "n4ind_ps.fh"
      integer rtdb
      integer junk
c
      if (.not. rtdb_get(rtdb, 'n4ind:pstat',
     $     MT_LOG, 1, on4indps)) on4indps = .false.
c
      call util_flush(6)
      if (.not. on4indps) return
c
      if (.not. pstat_allocate('tce:comp0', pstat_qstat, 0, junk,
     $     ps_comp0)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:sync0', pstat_qstat, 0, junk,
     $     ps_sync0)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:transp0', pstat_qstat, 0, junk,
     $     ps_transp0)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:int2e0', pstat_qstat, 0, junk,
     $     ps_int2e0)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comm0', pstat_qstat, 0, junk,
     $     ps_comm0)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comp1', pstat_qstat, 0, junk,
     $     ps_comp1)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comm1', pstat_qstat, 0, junk,
     $     ps_comm1)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:put1', pstat_qstat, 0, junk,
     $     ps_put1)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:get1', pstat_qstat, 0, junk,
     $     ps_get1)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comp2', pstat_qstat, 0, junk,
     $     ps_comp2)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comm2', pstat_qstat, 0, junk,
     $     ps_comm2)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comp3', pstat_qstat, 0, junk,
     $     ps_comp3)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comm3', pstat_qstat, 0, junk,
     $     ps_comm3)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:get3', pstat_qstat, 0, junk,
     $     ps_get3)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:put3', pstat_qstat, 0, junk,
     $     ps_put3)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:sync3', pstat_qstat, 0, junk,
     $     ps_sync3)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comp4', pstat_qstat, 0, junk,
     $     ps_comp4)) call errquit('tce: tce_pstat_init', 0,0)
      if (.not. pstat_allocate('tce:comm4', pstat_qstat, 0, junk,
     $     ps_comm4)) call errquit('tce: tce_pstat_init', 0,0)
c       
c
      end
      subroutine n4ind_pstat_print()
      implicit none
#include "pstat.fh"
#include "n4ind_ps.fh"
c     
      if (on4indps) then
         call pstat_off(ps_n4ind)
         call pstat_print_all
         on4indps = .false.
c
c     delete the TCE timers
c
         if (.not. pstat_free(ps_comm0))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_sync0))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_transp0))call errquit('dft_pstat?',0,0)
         if (.not. pstat_free(ps_comp0))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comm1))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_get1))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_put1))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comp1))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comm2))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comp2))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comm3))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_put3))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_get3))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_sync3))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comp3))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comm4))call errquit('dft_pstat?', 0,0)
         if (.not. pstat_free(ps_comp4))call errquit('dft_pstat?', 0,0)
c
      endif
c
      end
c $Id$
      subroutine n4ind_fdist_init()
      implicit none
#include "dist.fh"
#include "n4ind_ps.fh"
#include "rtdb.fh"
      if (.not. on4indps) return
c
#if 0
      fdist_comp1 = getdist( 'n4ind_comp1')
      fdist_comm1 = getdist( 'n4ind_comm1')
#endif
c
      end
      subroutine n4ind_transp(k_4a,k_work1,nalength,
     M     mu_range,nu_range,rho_range,sigma_range,
     S     shift_mu,shift_nu,shift_rho,shift_sigma,
     A     azone1,azone3,azone4)
      implicit none
      double precision k_4a(*),k_work1(*)
      integer nalength(*)
      integer mu_range,nu_range,rho_range,sigma_range
      integer shift_mu,shift_nu,shift_rho,shift_sigma
      integer azone1,azone3,azone4
c
      integer i
      integer mu1,nu1,rho1,sigma1
      integer imu1,inu1,irho1,isigma1
      integer ipos1
c      
      i=0
c      i=1
      do imu1     = shift_mu+1,shift_mu+mu_range
         do inu1     = shift_nu+1,shift_nu+nu_range
            do irho1    = shift_rho+1,shift_rho+rho_range
               ipos1=(((imu1-1)*nalength(azone1)+inu1-1)*
     1                 nalength(azone4)+irho1-1)*nalength(azone3)+
     +              shift_sigma
cold               do isigma1  = shift_sigma+1,shift_sigma+sigma_range
               do isigma1  = 1,sigma_range
cold                  i=i+1
c     (isigma1,irho1|inu1, imu1)
c     2                 +isigma1
                  k_4a(ipos1+isigma1)=k_work1(i+isigma1)
               enddo
               i=i+sigma_range
            enddo
         enddo
      enddo
      return
      end
      subroutine n4cache_init()
      implicit none
#include "n4cache.fh"
      integer i
c
      cache_hits=0
      n4caches=0
#if 0
      do i=1,max_n4caches
         n4cache_indx(1,i)=-1
         n4cache_indx(2,i)=-1
      enddo
#endif
      return
      end
      logical function n4cache_found(indx_lo,indx_hi,no_cache)
      implicit none
      integer indx_lo,indx_hi ! [in]
      integer no_cache       ! [out]
#include "n4cache.fh"
#include "global.fh"
      integer i
      logical oprint
c
      n4cache_found=.false.
      no_cache=0
      oprint=ga_nodeid().eq.0
#ifdef DBG
      if(oprint) write(6,'(i5,a,2i15)') ga_nodeid(),'n4cache_found in ',
     C     indx_lo,indx_hi
#else
      oprint=.false.
#endif
      if(n4caches.eq.0) return
      do i=1,n4caches
      if(oprint) write(6,'(i5,a,2i15)') i,'n4cache_found indx ',
     C     n4cache_indx(1,i),n4cache_indx(2,i)
         n4cache_found=indx_lo.eq.n4cache_indx(1,i).and.
     A        indx_hi.eq.n4cache_indx(2,i)
         if(n4cache_found) then
            no_cache=i
            return
         endif
      enddo
      return
      end
      integer function n4cache_newentry(indx_lo,indx_hi)
      implicit none
      integer indx_lo,indx_hi ! [in]
#include "n4cache.fh"
#include "mafdecls.fh"
c
      integer l_a,k_a
c
      n4cache_newentry=0
c     can't store any longer
      if(n4caches+1.gt.max_n4caches) return
      IF(ma_push_get(mt_dbl,indx_hi-indx_lo+1,'n4cache',l_a,k_a)) then
         n4caches=n4caches+1
         n4cache_indx(1,n4caches)=indx_lo
         n4cache_indx(2,n4caches)=indx_hi
c     store with ma_push
	 n4cache_hndl(1,n4caches)=l_a
	 n4cache_hndl(2,n4caches)=k_a
         n4cache_newentry=n4caches
      endif
      return
      end
      subroutine n4cache_stop()
      implicit none
#include "n4cache.fh"
#include "mafdecls.fh"
#include "errquit.fh"
#include "global.fh"
c
      integer i
c
      if(n4caches.eq.0) return
         write(6,'(i9,a,i8,a,i8,a,f6.2)') ga_nodeid(),
     N        ' n4caches ',n4caches,
     V        ' cache_hits ',cache_hits,
     R        ' ratio cache_hits/n4caches',
     1        1d0*cache_hits/n4caches
      do i=n4caches,1,-1
c     deallocate MAs
      if (.not.ma_pop_stack(n4cache_hndl(1,i))) then
         call ma_summarize_allocated_blocks()
         call errquit('n4cache_stop: pop_stack failure',i,MA_ERR)
      endif
      enddo
      n4caches=0
      cache_hits=0
      return
      end
      subroutine n4cache_storentry(buf_in,no_cache)
      implicit none
      integer no_cache            ! [in]
      double precision buf_in(*)  ! [in]
#include "n4cache.fh"
#include "mafdecls.fh"
#include "global.fh"
c
      call dcopy(n4cache_indx(2,no_cache)-n4cache_indx(1,no_cache)+1,
     c     buf_in,1,
     C     dbl_mb(n4cache_hndl(2,no_cache)),1)
#ifdef DBG
      if(ga_nodeid().eq.0) then
      write(6,*) ' Stored cache no ',no_cache
      write(6,'(a,2i20)') ' indx ',n4cache_indx(1,no_cache),
     C     n4cache_indx(2,no_cache)
      write(6,*) ' first elem ',buf_in(1)
      write(6,*) ' last elem ',buf_in(
     N     n4cache_indx(2,no_cache)-n4cache_indx(1,no_cache)+1)
      write(6,*) '=========='
      endif
#endif
      return
      end
      subroutine n4cache_getentry(buf_out,no_cache)
      implicit none
      integer no_cache             ! [in]
      double precision buf_out(*)  ! [out]
#include "n4cache.fh"
#include "mafdecls.fh"
#include "global.fh"
c
c
      cache_hits=cache_hits+1
      call dcopy(n4cache_indx(2,no_cache)-n4cache_indx(1,no_cache)+1,
     C     dbl_mb(n4cache_hndl(2,no_cache)),1,
     c     buf_out,1)
#ifdef DBG
      if(ga_nodeid().eq.0) then
      write(6,*) ' Fetched cache no ',no_cache
      write(6,'(a,2i20)') ' indx ',n4cache_indx(1,no_cache),
     C     n4cache_indx(2,no_cache)
      write(6,*) ' first elem ',buf_out(1)
      write(6,*) ' last elem ',buf_out(
     N     n4cache_indx(2,no_cache)-n4cache_indx(1,no_cache)+1)
      write(6,*) '=========='
      endif
#endif
      return
      end
      subroutine n4cache_get4af(ilo,ihi,d_4af,aux3)
      implicit none
      integer d_4af
      integer ilo,ihi          ! [in]
      double precision aux3(*) ! [out]
c
      integer no_cache
      logical n4cache_found
      integer n4cache_newentry
      external n4cache_found,n4cache_newentry
c
      if(.not.n4cache_found(ilo,ihi, no_cache)) then
         call ga_get(d_4af,ilo,ihi,1,1, aux3,ihi-ilo+1)
         no_cache=n4cache_newentry(ilo,ihi)
         if(no_cache.ne.0)
     c        call n4cache_storentry(aux3,no_cache)
      else
         call n4cache_getentry(aux3,no_cache)
      endif
      return
      end
