head	1.4;
access;
symbols;
locks
	D3Y133:1.4; strict;
comment	@c @;


1.4
date	2015.03.17.06.41.04;	author D3Y133;	state Exp;
branches;
next	1.3;

1.3
date	2014.12.26.07.06.41;	author D3Y133;	state Exp;
branches;
next	1.2;

1.2
date	2014.12.23.08.10.47;	author D3Y133;	state Exp;
branches;
next	1.1;

1.1
date	2014.12.21.08.31.55;	author D3Y133;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Added interface declarations.
@
text
@      SUBROUTINE WFN1_AD_DSYEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK,
     $           INFO )
      USE WFN1_AD1
      IMPLICIT NONE
#include "blas/double/intf_wfn1_ad_dscal.fh"
#include "lapack/double/intf_wfn1_ad_dlansy.fh"
#include "lapack/double/intf_wfn1_ad_dlascl.fh"
#include "lapack/double/intf_wfn1_ad_dorgtr.fh"
#include "lapack/double/intf_wfn1_ad_dsteqr.fh"
#include "lapack/double/intf_wfn1_ad_dsterf.fh"
#include "lapack/double/intf_wfn1_ad_dsytrd.fh"
*
*  -- LAPACK driver routine (version 3.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          JOBZ, UPLO
      INTEGER            INFO, LDA, LWORK, N
*     ..
*     .. Array Arguments ..
      TYPE(WFN1_AD_DBLE) :: A( LDA, * ), W( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  DSYEV computes all eigenvalues and, optionally, eigenvectors of a
*  real symmetric matrix A.
*
*  Arguments
*  =========
*
*  JOBZ    (input) CHARACTER*1
*          = 'N':  Compute eigenvalues only;
*          = 'V':  Compute eigenvalues and eigenvectors.
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  Upper triangle of A is stored;
*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
*          On entry, the symmetric matrix A.  If UPLO = 'U', the
*          leading N-by-N upper triangular part of A contains the
*          upper triangular part of the matrix A.  If UPLO = 'L',
*          the leading N-by-N lower triangular part of A contains
*          the lower triangular part of the matrix A.
*          On exit, if JOBZ = 'V', then if INFO = 0, A contains the
*          orthonormal eigenvectors of the matrix A.
*          If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
*          or the upper triangle (if UPLO='U') of A, including the
*          diagonal, is destroyed.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  W       (output) DOUBLE PRECISION array, dimension (N)
*          If INFO = 0, the eigenvalues in ascending order.
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The length of the array WORK.  LWORK >= max(1,3*N-1).
*          For optimal efficiency, LWORK >= (NB+2)*N,
*          where NB is the blocksize for DSYTRD returned by ILAENV.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, the algorithm failed to converge; i
*                off-diagonal elements of an intermediate tridiagonal
*                form did not converge to zero.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO
      TYPE(WFN1_AD_DBLE) :: ONE
      PARAMETER          ( ZERO = 0.0D0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LOWER, LQUERY, WANTZ
      INTEGER            IINFO, IMAX, INDE, INDTAU, INDWRK, ISCALE,
     $                   LLWORK, LWKOPT, NB
      DOUBLE PRECISION   BIGNUM, EPS, RMAX, RMIN, SAFMIN, SMLNUM
      TYPE(WFN1_AD_DBLE) :: ANRM, SIGMA
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      DOUBLE PRECISION   DLAMCH
      EXTERNAL           LSAME, ILAENV, DLAMCH
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     ..
*     .. Intrinsic Functions ..
c     INTRINSIC          MAX, SQRT
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      ONE   = 1.0d0
      WANTZ = LSAME( JOBZ, 'V' )
      LOWER = LSAME( UPLO, 'L' )
      LQUERY = ( LWORK.EQ.-1 )
*
      INFO = 0
      IF( .NOT.( WANTZ .OR. LSAME( JOBZ, 'N' ) ) ) THEN
         INFO = -1
      ELSE IF( .NOT.( LOWER .OR. LSAME( UPLO, 'U' ) ) ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      END IF
*
      IF( INFO.EQ.0 ) THEN
         NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 )
         LWKOPT = MAX( 1, ( NB+2 )*N )
         WORK( 1 ) = LWKOPT*1.0d0
*
         IF( LWORK.LT.MAX( 1, 3*N-1 ) .AND. .NOT.LQUERY )
     $      INFO = -8
      END IF
*
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DSYEV ', -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 ) THEN
         RETURN
      END IF
*
      IF( N.EQ.1 ) THEN
         W( 1 ) = A( 1, 1 )
         WORK( 1 ) = 2.0d0
         IF( WANTZ )
     $      A( 1, 1 ) = ONE
         RETURN
      END IF
*
*     Get machine constants.
*
      SAFMIN = DLAMCH( 'Safe minimum' )
      EPS = DLAMCH( 'Precision' )
      SMLNUM = SAFMIN / EPS
      BIGNUM = 1.0d0 / SMLNUM
      RMIN = SQRT( SMLNUM )
      RMAX = SQRT( BIGNUM )
*
*     Scale matrix to allowable range, if necessary.
*
      ANRM = WFN1_AD_DLANSY( 'M', UPLO, N, A, LDA, WORK )
      ISCALE = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.RMIN ) THEN
         ISCALE = 1
         SIGMA = RMIN / ANRM
      ELSE IF( ANRM.GT.RMAX ) THEN
         ISCALE = 1
         SIGMA = RMAX / ANRM
      END IF
      IF( ISCALE.EQ.1 )
     $   CALL WFN1_AD_DLASCL( UPLO, 0, 0, ONE, SIGMA, N, N, A, LDA,
     $        INFO )
*
*     Call DSYTRD to reduce symmetric matrix to tridiagonal form.
*
      INDE = 1
      INDTAU = INDE + N
      INDWRK = INDTAU + N
      LLWORK = LWORK - INDWRK + 1
      CALL WFN1_AD_DSYTRD( UPLO, N, A, LDA, W, WORK( INDE ),
     $     WORK( INDTAU ), WORK( INDWRK ), LLWORK, IINFO )
*
*     For eigenvalues only, call DSTERF.  For eigenvectors, first call
*     DORGTR to generate the orthogonal matrix, then call DSTEQR.
*
      IF( .NOT.WANTZ ) THEN
         CALL WFN1_AD_DSTERF( N, W, WORK( INDE ), INFO )
      ELSE
         CALL WFN1_AD_DORGTR( UPLO, N, A, LDA, WORK( INDTAU ),
     $        WORK( INDWRK ), LLWORK, IINFO )
         CALL WFN1_AD_DSTEQR( JOBZ, N, W, WORK( INDE ), A, LDA,
     $        WORK( INDTAU ), INFO )
      END IF
*
*     If matrix was scaled, then rescale eigenvalues appropriately.
*
      IF( ISCALE.EQ.1 ) THEN
         IF( INFO.EQ.0 ) THEN
            IMAX = N
         ELSE
            IMAX = INFO - 1
         END IF
         CALL WFN1_AD_DSCAL( IMAX, ONE / SIGMA, W, 1 )
      END IF
*
*     Set WORK(1) to optimal workspace size.
*
      WORK( 1 ) = LWKOPT*1.0d0
*
      RETURN
*
*     End of DSYEV
*
      END
@


1.3
log
@It is amazing that there still are routines with unnecessary 
implicit typing.
@
text
@d5 7
d102 1
a102 2
      TYPE(WFN1_AD_DBLE) :: WFN1_AD_DLANSY
      EXTERNAL           LSAME, ILAENV, DLAMCH, DLANSY
d105 1
a105 3
      EXTERNAL           WFN1_AD_DLASCL, WFN1_AD_DORGTR, WFN1_AD_DSCAL,
     $                   WFN1_AD_DSTEQR, WFN1_AD_DSTERF, WFN1_AD_DSYTRD,
     $                   XERBLA
@


1.2
log
@Fixing the usual suspects for AD.
@
text
@d4 1
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
      TYPE(WFN1_AD_DBLE) :: DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * )
d79 3
a81 2
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
d98 2
a99 1
      EXTERNAL           DLASCL, DORGTR, DSCAL, DSTEQR, DSTERF, DSYTRD,
d103 1
a103 1
      INTRINSIC          MAX, SQRT
d109 1
d128 1
a128 1
         WORK( 1 ) = LWKOPT
d149 1
a149 1
         WORK( 1 ) = 2
d160 1
a160 1
      BIGNUM = ONE / SMLNUM
d213 1
a213 1
      WORK( 1 ) = LWKOPT
@
