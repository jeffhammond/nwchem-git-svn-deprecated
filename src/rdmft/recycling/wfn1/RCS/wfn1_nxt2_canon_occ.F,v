head	1.6;
access;
symbols;
locks
	hvandam:1.6; strict;
comment	@c @;


1.6
date	2015.11.28.23.56.41;	author hvandam;	state Exp;
branches;
next	1.5;

1.5
date	2015.11.22.23.40.54;	author hvandam;	state Exp;
branches;
next	1.4;

1.4
date	2015.11.22.22.25.48;	author hvandam;	state Exp;
branches;
next	1.3;

1.3
date	2015.05.09.05.24.09;	author D3Y133;	state Exp;
branches;
next	1.2;

1.2
date	2015.04.06.05.35.49;	author D3Y133;	state Exp;
branches;
next	1.1;

1.1
date	2015.03.23.04.34.16;	author D3Y133;	state Exp;
branches;
next	;


desc
@Canonicalize the occupation functions.
@


1.6
log
@Suppressed the canonicalization over the RDMFT Fock matrix. The degeneracies
get in the way of everything anyway.
@
text
@C> \ingroup wfn1_nxt2
C> @@{
C>
C> \brief Create a new state canonicalizing everything
C>
C> As with regular effective 1-electron models there are redundant
C> rotations in this model also. For the occupation functions those
C> redundant rotations are easily identified as mixings in the 
C> occupied-occupied block and the virtual-virtual block. For the
C> natural orbitals this distinction is not so clear cut as they have
C> fractional occupations. Hence we construct a regular Fock matrix
C> and diagonalize that to canonicalize the natural orbitals.
C>
C> A problem with canonicalizing the orbitals in this setting is 
C> that because of the degeneracies due to Gilbert's theorem even the
C> canonical orbitals may be arbitrarily mixed. A double
C> canonicalization may be needed to fix this. 
C>
      subroutine wfn1_nxt2_canon_all(nbf,nea,neb,statein,fock,stateout)
      implicit none
c
#include "errquit.fh"
#include "mafdecls.fh"
#include "wfn1_nxt.fh"
c
      integer nbf !< [Input] The number of basis functions
      integer nea !< [Input] The number of alpha electrons
      integer neb !< [Input] The number of beta electrons
c
      double precision statein(8*nbf*nbf+2*nbf) !< [Input] The initial state
      double precision fock(8*nbf*nbf)    !< [Input] The fock matrices
c
      double precision stateout(8*nbf*nbf+2*nbf) !< [Input] The final state
c
      double precision tt
      double precision levelshift
      parameter(levelshift = -1.0d0)
c
      integer info  !< The status flag for DSYEV
      integer lwork !< The work space size for DSYEV
      integer iocn  !< Offset short hand for occupation numbers
      integer iocf  !< Offset short hand for occupation functions
      integer icnf  !< Offset short hand for electron configurations
c
      integer l_m1,   k_m1
      integer l_m2,   k_m2
      integer l_exp,  k_exp
      integer l_occa, k_occa
      integer l_occb, k_occb
      integer l_gg,   k_gg
c
      integer ir !< Counter
      integer iq !< Counter
      integer ii !< Counter
      integer jj !< Counter
c
c     Allocate memory
c
      lwork = max(nbf*nbf,3*nbf)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"tmp1",l_m1,k_m1))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,lwork,"tmp2",l_m2,k_m2))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"exp",l_exp,k_exp))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      if (.not.ma_push_get(MT_DBL,nbf,"occa",l_occa,k_occa))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate occa",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"occb",l_occb,k_occb))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate occb",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"gershgorin",l_gg,k_gg))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate gg",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
c
c     Compute the occupation numbers
c
      call dfill(nbf,0.0d0,dbl_mb(k_occa),1)
      call dfill(nbf,0.0d0,dbl_mb(k_occb),1)
c
      icnf = wfn1_nxt_aconf()
      iocf = wfn1_nxt_aocc()
      iocn = k_occa
      do ir = 0, nbf-1
        do ii = 0, nbf-1
          dbl_mb(iocn+ii) = dbl_mb(iocn+ii)
     &       + statein(iocf+ii+ir*nbf)*statein(iocf+ii+ir*nbf)
     &         *statein(icnf+ir)
        enddo 
      enddo
c
      icnf = wfn1_nxt_bconf()
      iocf = wfn1_nxt_bocc()
      iocn = k_occb
      do ir = 0, nbf-1
        do ii = 0, nbf-1
          dbl_mb(iocn+ii) = dbl_mb(iocn+ii)
     &       + statein(iocf+ii+ir*nbf)*statein(iocf+ii+ir*nbf)
     &         *statein(icnf+ir)
        enddo 
      enddo
c
c     Initialize state out
c
      call dcopy(wfn1_nxt_size1(),statein,1,stateout,1)
c
c     Alpha natural orbitals (occupied part)
c     --------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_anat()),1,dbl_mb(k_exp),1)
c
c     scale columns
c
      do ii = 0, nbf-1
c       call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
c       just diagonal
        dbl_mb(k_exp+ii*nbf+ii) = dbl_mb(k_exp+ii*nbf+ii)
     +                          * dbl_mb(k_occa+ii)
      enddo
c
c     scale rows
c
c     do ii = 0, nbf-1
c       call dscal(nbf,sqrt(dbl_mb(k_occa+ii)),dbl_mb(k_exp+ii),nbf)
c     enddo
c
c     Alpha natural orbitals (virtual part)
c     -------------------------------------
c
c     call dcopy(nbf*nbf,fock(wfn1_nxt_anat()),1,dbl_mb(k_m1),1)
c     do ii = 0, nbf-1
c       dbl_mb(k_occa+ii) = 1.0d0 - dbl_mb(k_occa+ii)
c     enddo
c
c     scale columns
c
c     do ii = 0, nbf-1
c       call dscal(nbf,sqrt(dbl_mb(k_occa+ii)),dbl_mb(k_m1+ii*nbf),1)
c     enddo
c
c     scale rows
c
c     do ii = 0, nbf-1
c       call dscal(nbf,sqrt(dbl_mb(k_occa+ii)),dbl_mb(k_m1+ii),nbf)
c     enddo
c
c     Add occupied-occupied and virtual-virtual blocks
c
c     call daxpy(nbf*nbf,1.0d0,dbl_mb(k_m1),1,dbl_mb(k_exp),1)
c
c     Print diagonal elements of Fock matrix
c
      write(*,*)'wfn1_nxt2_canon_all'
      write(*,*)'Alpha natural orbital Fock elements'
      do ii = 0, nbf-1
        write(*,'(i4,2f14.6)')ii+1,dbl_mb(k_occa+ii),
     +                             dbl_mb(k_exp+ii+nbf*ii)
      enddo
c     write(*,*)'Alpha natural orbital original Fock'
c     call hess_hssout(fock(wfn1_nxt_anat()),nbf,nbf,nbf)
c     write(*,*)'Alpha natural orbital occ-occ+virt-virt Fock'
c     call hess_hssout(dbl_mb(k_exp),nbf,nbf,nbf)
c
c     - symmetrize
c
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
c
c     - sort stuff
c
c     call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
c    &     statein(wfn1_nxt_anat()),statein(wfn1_nxt_aocc()))
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occa))
c
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
c
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
cDEBUG
c     write(*,*)'Alpha natural orbital Fock eigenvalues'
c     do ii = 0, nbf-1
c       write(*,*)ii+1,dbl_mb(k_m1+ii)
c     enddo
c     call hess_hssout(dbl_mb(k_exp),nbf,nbf,nbf)
cDEBUG
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed a: ",info,UERR)
      endif
c     call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_anat()),nbf,
c    &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_anat()),nbf)
c     call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
c    &           statein(wfn1_nxt_aocc()),nbf,
c    &           0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c
c     Beta natural orbitals (occupied part)
c     -------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_bnat()),1,dbl_mb(k_exp),1)
c
c     Scale columns
c
      do ii = 0, nbf-1
c       call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
c       just diagonal
        dbl_mb(k_exp+ii*nbf+ii) = dbl_mb(k_exp+ii*nbf+ii)
     +                          * dbl_mb(k_occb+ii)
      enddo
c
c     Scale rows
c
c     do ii = 0, nbf-1
c       call dscal(nbf,sqrt(dbl_mb(k_occb+ii)),dbl_mb(k_exp+ii),nbf)
c     enddo
c
c     Beta natural orbitals (virtual part)
c     ------------------------------------
c
c     call dcopy(nbf*nbf,fock(wfn1_nxt_bnat()),1,dbl_mb(k_m1),1)
c     do ii = 0, nbf-1
c       dbl_mb(k_occb+ii) = 1.0d0 - dbl_mb(k_occb+ii)
c     enddo
c
c     Scale columns
c
c     do ii = 0, nbf-1
c       call dscal(nbf,sqrt(dbl_mb(k_occb+ii)),dbl_mb(k_m1+ii*nbf),1)
c     enddo
c
c     Scale rows
c
c     do ii = 0, nbf-1
c       call dscal(nbf,sqrt(dbl_mb(k_occb+ii)),dbl_mb(k_m1+ii),nbf)
c     enddo
c
c     Add occupied-occupied and virtual-virtual blocks
c
c     call daxpy(nbf*nbf,1.0d0,dbl_mb(k_m1),1,dbl_mb(k_exp),1)
c
c     Print diagonal elements of Fock matrix
c
      write(*,*)'Beta natural orbital Fock elements'
      do ii = 0, nbf-1
        write(*,'(i4,2f14.6)')ii+1,dbl_mb(k_occb+ii),
     +                             dbl_mb(k_exp+ii+nbf*ii)
      enddo
c
c     - symmetrize
c
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
c
c     - sort stuff
c
c     call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
c    &     statein(wfn1_nxt_bnat()),statein(wfn1_nxt_bocc()))
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occb))
c
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
c
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed c: ",info,UERR)
      endif
c     call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bnat()),nbf,
c    &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bnat()),nbf)
c     call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
c    &           statein(wfn1_nxt_bocc()),nbf,
c    &           0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Alpha occupation functions (occupied part)
c     ------------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_exp),1)
      call dcopy(nbf,statein(wfn1_nxt_aconf()),1,dbl_mb(k_occa),1)
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii),nbf)
      enddo
c
c     Alpha occupation functions (virtual part)
c     ------------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_m2),1)
      do ii = 0, nbf-1
        dbl_mb(k_occa+ii) = 1.0d0 - dbl_mb(k_occa+ii)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_m2+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_m2+ii),nbf)
      enddo
      do ii = 0, nbf-1
        dbl_mb(k_occa+ii) = 1.0d0 - dbl_mb(k_occa+ii)
      enddo
c
c     Sum occupied-occupied and virtual-virtual blocks
c
      call daxpy(nbf*nbf,1.0d0,dbl_mb(k_m2),1,dbl_mb(k_exp),1)
c
c     Print diagonal elements of Fock matrix
c
      write(*,*)'Alpha occupation function Fock elements'
      do ii = 0, nbf-1
        write(*,'(i4,2f14.6)')ii+1,dbl_mb(k_occa+ii),
     &                             dbl_mb(k_exp+ii+nbf*ii)
      enddo
c
c     - symmetrize
c
c     do jj = 0, nbf-1
c       do ii = jj+1, nbf-1
c         tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
c         dbl_mb(k_exp+ii+jj*nbf) = tt
c         dbl_mb(k_exp+jj+ii*nbf) = tt
c       enddo
c     enddo
c
c     - sort stuff
c
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occa))
c
c     - establish rotation and apply it to the occupation functions
c
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed e: ",info,UERR)
      endif
      call dcopy(nbf*nbf,stateout(wfn1_nxt_aocc()),1,dbl_mb(k_m2),1)
c     call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m2),nbf,
c    &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c
c     Beta occupation functions (occupied part)
c     -----------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_bocc()),1,dbl_mb(k_exp),1)
      call dcopy(nbf,statein(wfn1_nxt_bconf()),1,dbl_mb(k_occb),1)
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii),nbf)
      enddo
c
c     Beta occupation functions (virtual part)
c     ----------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_bocc()),1,dbl_mb(k_m2),1)
      do ii = 0, nbf-1
        dbl_mb(k_occb+ii) = 1.0d0 - dbl_mb(k_occb+ii)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_m2+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_m2+ii),nbf)
      enddo
      do ii = 0, nbf-1
        dbl_mb(k_occb+ii) = 1.0d0 - dbl_mb(k_occb+ii)
      enddo
c
c     Sum occupied-occupied and virtual-virtual blocks
c
      call daxpy(nbf*nbf,1.0d0,dbl_mb(k_m2),1,dbl_mb(k_exp),1)
c
c     Print diagonal elements of Fock matrix
c
      write(*,*)'Beta occupation function Fock elements'
      do ii = 0, nbf-1
        write(*,'(i4,2f14.6)')ii+11,dbl_mb(k_occb+ii),
     &                              dbl_mb(k_exp+ii+nbf*ii)
      enddo
c
c     - symmetrize
c
c     do jj = 0, nbf-1
c       do ii = jj+1, nbf-1
c         tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
c         dbl_mb(k_exp+ii+jj*nbf) = tt
c         dbl_mb(k_exp+jj+ii*nbf) = tt
c       enddo
c     enddo
c
c     - sort stuff
c
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occb))
c
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
c
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1+nbf),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed g: ",info,UERR)
      endif
      call dcopy(nbf*nbf,stateout(wfn1_nxt_bocc()),1,dbl_mb(k_m2),1)
c     call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m2),nbf,
c    &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Print the occupation function eigenvalues
c
c     write(*,*)"occupation function energies"
c     do ir = 1, nbf
c       write(*,'(i4,2f14.6)')ir,dbl_mb(k_m1+(ir-1)),
c    &                           dbl_mb(k_m1+nbf+(ir-1))
c     enddo
c     write(*,*)
c
c     Alpha natural orbitals
c
      call dcopy(nbf    ,statein(wfn1_nxt_aconf()),1,
     &                   stateout(wfn1_nxt_aconf()),1)
c
c     Beta natural orbitals
c
      call dcopy(nbf    ,statein(wfn1_nxt_bconf()),1,
     &                   stateout(wfn1_nxt_bconf()),1)
c
c     Cleanup memory
c
      if (.not.ma_pop_stack(l_gg))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate gg",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_occb))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate occb",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_occa))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate occa",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      if (.not.ma_pop_stack(l_exp))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m2))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m1))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      end
C>
C> \brief Create a new state canonicalizing the occupation functions
C>
C> As with regular effective 1-electron models there are redundant
C> rotations in this model also. For the occupation functions those
C> redundant rotations are easily identified as mixings in the 
C> occupied-occupied block and the virtual-virtual block. 
C>
C> A problem with canonicalizing the orbitals in this setting is 
C> that because of the degeneracies due to Gilbert's theorem even the
C> canonical orbitals may be arbitrarily mixed. A double
C> canonicalization may be needed to fix this. 
C>
      subroutine wfn1_nxt2_canon_occ(nbf,nea,neb,statein,fock,stateout)
      implicit none
c
#include "errquit.fh"
#include "mafdecls.fh"
#include "wfn1_nxt.fh"
c
      integer nbf !< [Input] The number of basis functions
      integer nea !< [Input] The number of alpha electrons
      integer neb !< [Input] The number of beta electrons
c
      double precision statein(8*nbf*nbf+2*nbf) !< [Input] The initial state
      double precision fock(8*nbf*nbf)    !< [Input] The fock matrices
c
      double precision stateout(8*nbf*nbf+2*nbf) !< [Input] The final state
c
      double precision tt
      double precision levelshift
      parameter(levelshift = -1.0d0)
c
      integer info  !< The status flag for DSYEV
      integer lwork !< The work space size for DSYEV
      integer iocn  !< Offset short hand for occupation numbers
      integer iocf  !< Offset short hand for occupation functions
      integer icnf  !< Offset short hand for electron configurations
c
      integer l_m1,   k_m1
      integer l_m2,   k_m2
      integer l_exp,  k_exp
      integer l_occa, k_occa
      integer l_occb, k_occb
      integer l_gg,   k_gg
c
      integer ir !< Counter
      integer iq !< Counter
      integer ii !< Counter
      integer jj !< Counter
c
c     Allocate memory
c
      lwork = max(nbf*nbf,3*nbf)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"tmp1",l_m1,k_m1))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,lwork,"tmp2",l_m2,k_m2))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"exp",l_exp,k_exp))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      if (.not.ma_push_get(MT_DBL,nbf,"occa",l_occa,k_occa))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate occa",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"occb",l_occb,k_occb))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate occb",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"gershgorin",l_gg,k_gg))
     &  call errquit("wfn1_nxt2_canon_occ: could not allocate gg",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
c
c     Initialize state out
c
      call dcopy(wfn1_nxt_size1(),statein,1,stateout,1)
c
c     Alpha occupation functions (occupied part)
c     ------------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_exp),1)
      call dcopy(nbf,statein(wfn1_nxt_aconf()),1,dbl_mb(k_occa),1)
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii),nbf)
      enddo
c
c     Alpha occupation functions (virtual part)
c     ------------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_m2),1)
      do ii = 0, nbf-1
        dbl_mb(k_occa+ii) = 1.0d0 - dbl_mb(k_occa+ii)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_m2+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_m2+ii),nbf)
      enddo
c
c     Sum occupied-occupied and virtual-virtual blocks
c
      call daxpy(nbf*nbf,1.0d0,dbl_mb(k_m2),1,dbl_mb(k_exp),1)
c
c     Print diagonal elements of Fock matrix
c
      write(*,*)'wfn1_nxt2_canon_occ'
      write(*,*)'Alpha occupation function Fock elements'
      do ii = 0, nbf-1
        write(*,'(i4,2f14.6)')ii+1,1.0d0-dbl_mb(k_occa+ii),
     &                             dbl_mb(k_exp+ii+nbf*ii)
      enddo
c
c     - symmetrize
c
c     do jj = 0, nbf-1
c       do ii = jj+1, nbf-1
c         tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
c         dbl_mb(k_exp+ii+jj*nbf) = tt
c         dbl_mb(k_exp+jj+ii*nbf) = tt
c       enddo
c     enddo
c
c     - sort stuff
c
c     call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
c     call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
c    &                      dbl_mb(k_occa))
c
c     - establish rotation and apply it to the occupation functions
c
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed e: ",info,UERR)
      endif
      call dcopy(nbf*nbf,stateout(wfn1_nxt_aocc()),1,dbl_mb(k_m2),1)
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m2),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c
c     Print occupation function energies
c
      write(*,*)'Alpha occupation function Hartree-Fock energies'
      do ii = 0, nbf-1
        write(*,'(i4,2f14.6)')ii+1,1.0d0-dbl_mb(k_occa+ii),
     &                             dbl_mb(k_m1+ii)
      enddo
c
c     Beta occupation functions (occupied part)
c     -----------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_bocc()),1,dbl_mb(k_exp),1)
      call dcopy(nbf,statein(wfn1_nxt_bconf()),1,dbl_mb(k_occb),1)
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii),nbf)
      enddo
c
c     Beta occupation functions (virtual part)
c     ----------------------------------------
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_bocc()),1,dbl_mb(k_m2),1)
      do ii = 0, nbf-1
        dbl_mb(k_occb+ii) = 1.0d0 - dbl_mb(k_occb+ii)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_m2+ii*nbf),1)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_m2+ii),nbf)
      enddo
c
c     Sum occupied-occupied and virtual-virtual blocks
c
      call daxpy(nbf*nbf,1.0d0,dbl_mb(k_m2),1,dbl_mb(k_exp),1)
c
c     - symmetrize
c
c     do jj = 0, nbf-1
c       do ii = jj+1, nbf-1
c         tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
c         dbl_mb(k_exp+ii+jj*nbf) = tt
c         dbl_mb(k_exp+jj+ii*nbf) = tt
c       enddo
c     enddo
c
c     - sort stuff
c
c     call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
c     call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
c    &                      dbl_mb(k_occb))
c
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
c
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1+nbf),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed g: ",info,UERR)
      endif
      call dcopy(nbf*nbf,stateout(wfn1_nxt_bocc()),1,dbl_mb(k_m2),1)
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m2),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Print occupation function energies
c
      write(*,*)'Alpha-Beta occupation function Hartree-Fock energies'
      do ii = 0, nbf-1
        write(*,'(i4,4f14.6)')ii+1,
     &     1.0d0-dbl_mb(k_occa+ii),
     &     1.0d0-dbl_mb(k_occb+ii),
     &     dbl_mb(k_m1+ii),
     &     dbl_mb(k_m1+nbf+ii)
      enddo
cDEBUG
      write(*,*)'Alpha occupation functions after HF canonicalization'
      call hess_hssout(stateout(wfn1_nxt_aocc()),nbf,nbf,nbf)
      write(*,*)'Beta occupation functions after HF canonicalization'
      call hess_hssout(stateout(wfn1_nxt_bocc()),nbf,nbf,nbf)
cDEBUG
c
c     Print the occupation function eigenvalues
c
c     write(*,*)"occupation function energies"
c     do ir = 1, nbf
c       write(*,'(i4,2f14.6)')ir,dbl_mb(k_m1+(ir-1)),
c    &                           dbl_mb(k_m1+nbf+(ir-1))
c     enddo
c     write(*,*)
c
c     Alpha natural orbitals
c
      call dcopy(nbf    ,statein(wfn1_nxt_aconf()),1,
     &                   stateout(wfn1_nxt_aconf()),1)
c
c     Beta natural orbitals
c
      call dcopy(nbf    ,statein(wfn1_nxt_bconf()),1,
     &                   stateout(wfn1_nxt_bconf()),1)
c
c     Cleanup memory
c
      if (.not.ma_pop_stack(l_gg))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate gg",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_occb))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate occb",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_occa))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate occa",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      if (.not.ma_pop_stack(l_exp))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m2))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m1))
     &  call errquit("wfn1_nxt2_canon_occ: could not deallocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      end
C> @@}
@


1.5
log
@Removed the coupling between updating the natural orbitals
and the occupation functions.
@
text
@d119 4
a122 1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
a188 4
cDEBUG
c     write(*,*)'Alpha natural orbital Fock before dsyev'
c     call hess_hssout(dbl_mb(k_exp),nbf,nbf,nbf)
cDEBUG
d202 2
a203 2
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_anat()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_anat()),nbf)
d216 4
a219 1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
d287 2
a288 2
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bnat()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bnat()),nbf)
d359 2
a360 2
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m2),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
d429 2
a430 2
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m2),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
d696 6
@


1.4
log
@Adding a routine to canonicalize the orbitals using the Hartree-Fock
Fock matrix.
@
text
@d205 3
a207 3
      call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
     &           statein(wfn1_nxt_aocc()),nbf,
     &           0.0d0,stateout(wfn1_nxt_aocc()),nbf)
d287 3
a289 3
      call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
     &           statein(wfn1_nxt_bocc()),nbf,
     &           0.0d0,stateout(wfn1_nxt_bocc()),nbf)
@


1.3
log
@Fixed up the orbital canonicalization. There are redundant rotations both
in the natural orbital Fock matrix as well as in the occupation function
Fock matrix. Actually the canonicalization can be implemented by analogy
for the natural orbital Fock matrix. I.e. canonicalizing the natural orbital
Fock matrix is analogous to canonicalizing the occupation function Fock
matrix.
@
text
@d4 9
a12 1
C> \brief Create a new state canonicalizing the occupation functions
d14 4
a17 4
C> Given that the orbitals at the Fermi level are all exactly
C> degenerate diagonalizing the proper Fock matrix will not work. 
C> Instead we diagonalize the Hartree-Fock Fock matrix. Important
C> is to decouple the occupied and virtual occupation functions.
d19 1
a19 1
      subroutine wfn1_nxt2_canon_occ(nbf,nea,neb,statein,fock,stateout)
d76 1
a76 1
      if (.not.ma_push_get(MT_DBL,nbf,"occb",l_gg,k_gg))
d91 2
a92 2
     &       + dbl_mb(iocf+ii+ir*nbf)*dbl_mb(iocf+ii+ir*nbf)
     &         *dbl_mb(icnf+ir)
d102 2
a103 2
     &       + dbl_mb(iocf+ii+ir*nbf)*dbl_mb(iocf+ii+ir*nbf)
     &         *dbl_mb(icnf+ir)
d112 1
d122 43
d177 2
a178 2
      call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
     &     statein(wfn1_nxt_anat()),statein(wfn1_nxt_aocc()))
d186 4
d193 7
d209 6
a214 1
c     Alpha natural orbitals (virtual part)
a215 1
      call dcopy(nbf*nbf,fock(wfn1_nxt_anat()),1,dbl_mb(k_exp),1)
d217 1
a217 4
        dbl_mb(k_occa+ii) = 1.0d0 - dbl_mb(k_occa+ii)
      enddo
      do ii = 0, nbf-1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
d220 15
a234 1
c     - symmetrize
d236 3
a238 7
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
d240 1
a240 1
c     - sort stuff
d242 3
a244 5
      call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
     &     stateout(wfn1_nxt_anat()),stateout(wfn1_nxt_aocc()))
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occa))
d246 1
a246 2
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
d248 1
a248 13
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed b: ",info,UERR)
      endif
      call dcopy(nbf*nbf,stateout(wfn1_nxt_anat()),1,dbl_mb(k_m1),1)
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m1),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_anat()),nbf)
      call dcopy(nbf*nbf,stateout(wfn1_nxt_aocc()),1,dbl_mb(k_m1),1)
      call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
     &           dbl_mb(k_m1),nbf,
     &           0.0d0,stateout(wfn1_nxt_aocc()),nbf)
d250 1
a250 1
c     Beta natural orbitals (occupied part)
d252 1
a252 1
      call dcopy(nbf*nbf,fock(wfn1_nxt_bnat()),1,dbl_mb(k_exp),1)
d254 2
a255 1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
d270 2
a271 2
      call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
     &     statein(wfn1_nxt_bnat()),statein(wfn1_nxt_bocc()))
d291 2
a292 1
c     Beta natural orbitals (virtual part)
d294 2
a295 1
      call dcopy(nbf*nbf,fock(wfn1_nxt_bnat()),1,dbl_mb(k_exp),1)
d297 1
a297 1
        dbl_mb(k_occb+ii) = 1.0d0 - dbl_mb(k_occb+ii)
d300 1
a300 1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
d303 2
a304 1
c     - symmetrize
d306 12
a317 6
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
d320 1
a320 1
c     - sort stuff
d322 1
a322 5
      call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
     &     stateout(wfn1_nxt_bnat()),stateout(wfn1_nxt_bocc()))
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occb))
d324 1
a324 2
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
d326 1
a326 18
      info = 0 
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_canon_occ: dsyev failed d: ",info,UERR)
      endif
      call dcopy(nbf*nbf,stateout(wfn1_nxt_bnat()),1,dbl_mb(k_m1),1)
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m1),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bnat()),nbf)
      call dcopy(nbf*nbf,stateout(wfn1_nxt_bocc()),1,dbl_mb(k_m1),1)
      call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
     &           dbl_mb(k_m1),nbf,
     &           0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Alpha occupation functions (occupied part)
c
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_exp),1)
      call dcopy(nbf,statein(wfn1_nxt_aconf()),1,dbl_mb(k_occa),1)
d328 2
a329 1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
d334 7
a340 7
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
d348 1
a348 2
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
d356 2
a357 1
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_aocc()),nbf,
d360 14
a373 1
c     Alpha occupation functions (virtual part)
d375 7
a381 1
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_exp),1)
d383 1
a383 1
        dbl_mb(k_occa+ii) = 1.0d0 - dbl_mb(k_occa+ii)
d386 13
a398 1
        call dscal(nbf,dbl_mb(k_occa+ii),dbl_mb(k_exp+ii*nbf),1)
d403 7
a409 7
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
d415 1
a415 1
     &                      dbl_mb(k_occa))
d421 1
a421 1
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
d424 1
a424 1
        call errquit("wfn1_nxt2_canon_occ: dsyev failed f: ",info,UERR)
d426 153
a578 3
      call dcopy(nbf*nbf,stateout(wfn1_nxt_aocc()),1,dbl_mb(k_m1),1)
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m1),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
d580 1
a580 1
c     Beta occupation functions (occupied part)
d582 2
a583 2
      call dcopy(nbf*nbf,fock(wfn1_nxt_bocc()),1,dbl_mb(k_exp),1)
      call dcopy(nbf,statein(wfn1_nxt_bconf()),1,dbl_mb(k_occb),1)
d585 2
a586 1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
d591 7
a597 7
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
d601 3
a603 3
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occb))
d605 1
a605 2
c     - establish rotation and apply it to both natural orbitals
c       and occupation functions
d611 1
a611 1
        call errquit("wfn1_nxt2_canon_occ: dsyev failed g: ",info,UERR)
d613 11
a623 2
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bocc()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
d625 2
a626 1
c     Alpha occupation functions (virtual part)
d629 12
d645 4
a648 1
        call dscal(nbf,dbl_mb(k_occb+ii),dbl_mb(k_exp+ii*nbf),1)
d651 4
d657 7
a663 7
      do jj = 0, nbf-1
        do ii = jj+1, nbf-1
          tt = 0.5d0*(dbl_mb(k_exp+ii+jj*nbf)+dbl_mb(k_exp+jj+ii*nbf))
          dbl_mb(k_exp+ii+jj*nbf) = tt
          dbl_mb(k_exp+jj+ii*nbf) = tt
        enddo
      enddo
d667 3
a669 3
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_gg))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_gg),levelshift,
     &                      dbl_mb(k_occb))
d675 1
a675 1
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
d678 1
a678 1
        call errquit("wfn1_nxt2_canon_occ: dsyev failed h: ",info,UERR)
d680 2
a681 2
      call dcopy(nbf*nbf,stateout(wfn1_nxt_bocc()),1,dbl_mb(k_m1),1)
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_m1),nbf,
d684 11
d697 6
a702 6
      write(*,*)"occupation function energies"
      do ir = 1, nbf
        write(*,'(i4,2f14.6)')ir,dbl_mb(k_m1+(ir-1)),
     &                           dbl_mb(k_m1+nbf+(ir-1))
      enddo
      write(*,*)
a705 2
      call dcopy(nbf*nbf,statein(wfn1_nxt_anat()),1,
     &                   stateout(wfn1_nxt_anat()),1)
a710 2
      call dcopy(nbf*nbf,statein(wfn1_nxt_bnat()),1,
     &                   stateout(wfn1_nxt_bnat()),1)
@


1.2
log
@Updated the orbital canonicalization routine.
@
text
@d27 1
d29 1
a29 1
      parameter(levelshift = 0.1d0)
d33 10
a42 4
c
      integer l_m1,  k_m1
      integer l_m2,  k_m2
      integer l_exp, k_exp
d46 2
d62 37
a101 3
cDEBUG
      write(*,*)'canonicalize'
cDEBUG
d103 174
a276 1
c     Alpha occupation functions
d279 3
a281 5
      do ir = 1, nbf
        if (statein(wfn1_nxt_aconf()+ir-1).le.0.0d0) then
          dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
     &       = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) + levelshift
        endif
d283 8
a290 11
      do ir = 1, nbf
        do iq = 1, nbf
          if (statein(wfn1_nxt_aconf()+ir-1).le.0.0d0.and.
     &        statein(wfn1_nxt_aconf()+iq-1).ge.1.0d0) then
            dbl_mb(k_exp+(ir-1)+(iq-1)*nbf) = 0.0d0
            dbl_mb(k_exp+(iq-1)+(ir-1)*nbf) = 0.0d0
          else if (statein(wfn1_nxt_aconf()+ir-1).ge.1.0d0.and.
     &             statein(wfn1_nxt_aconf()+iq-1).le.0.0d0) then
            dbl_mb(k_exp+(ir-1)+(iq-1)*nbf) = 0.0d0
            dbl_mb(k_exp+(iq-1)+(ir-1)*nbf) = 0.0d0
          endif
d293 10
a303 1
c     lwork = nbf*nbf
d307 1
a307 1
        call errquit("wfn1_nxt2_canon_occ: dsyev failed a: ",info,UERR)
d311 19
a329 4
      do ir = 1, nbf
        if (statein(wfn1_nxt_aconf()+ir-1).le.0.0d0) then
          dbl_mb(k_m1+(ir-1)) = dbl_mb(k_m1+(ir-1)) - levelshift
        endif
d332 20
a351 1
c     Beta occupation functions
d354 3
a356 5
      do ir = 1, nbf
        if (statein(wfn1_nxt_bconf()+ir-1).le.0.0d0) then
          dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
     &       = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) + levelshift
        endif
d358 8
a365 11
      do ir = 1, nbf
        do iq = 1, nbf
          if (statein(wfn1_nxt_bconf()+ir-1).le.0.0d0.and.
     &        statein(wfn1_nxt_bconf()+iq-1).ge.1.0d0) then
            dbl_mb(k_exp+(ir-1)+(iq-1)*nbf) = 0.0d0
            dbl_mb(k_exp+(iq-1)+(ir-1)*nbf) = 0.0d0
          else if (statein(wfn1_nxt_bconf()+ir-1).ge.1.0d0.and.
     &             statein(wfn1_nxt_bconf()+iq-1).le.0.0d0) then
            dbl_mb(k_exp+(ir-1)+(iq-1)*nbf) = 0.0d0
            dbl_mb(k_exp+(iq-1)+(ir-1)*nbf) = 0.0d0
          endif
d368 10
d379 1
a379 2
c     lwork = nbf*nbf
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1+nbf),
d382 1
a382 1
        call errquit("wfn1_nxt2_canon_occ: dsyev failed a: ",info,UERR)
d386 19
a404 4
      do ir = 1, nbf
        if (statein(wfn1_nxt_bconf()+ir-1).le.0.0d0) then
          dbl_mb(k_m1+nbf+(ir-1)) = dbl_mb(k_m1+nbf+(ir-1)) - levelshift
        endif
d407 19
d450 10
@


1.1
log
@Initial revision
@
text
@d6 4
a9 6
C> The new state is generated from the old one by applying appropriate
C> rotations. To generate the rotation matrix we diagonalize the 
C> occupation function Fock matrix. However, as the lowest virtual 
C> occupation functions may be degenerate with the highest occupied
C> occupation functions we need to apply a level shifter to break
C> the degeneracy.
d22 1
a22 1
      double precision statein(8*nbf*nbf) !< [Input] The initial state
d25 1
a25 1
      double precision stateout(8*nbf*nbf) !< [Input] The final state
d38 1
d56 3
d69 13
d105 13
@
