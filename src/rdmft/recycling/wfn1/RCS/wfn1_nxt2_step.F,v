head	1.8;
access;
symbols;
locks
	D3Y133:1.8; strict;
comment	@c @;


1.8
date	2015.05.09.05.58.10;	author D3Y133;	state Exp;
branches;
next	1.7;

1.7
date	2015.04.06.05.17.05;	author D3Y133;	state Exp;
branches;
next	1.6;

1.6
date	2015.04.02.06.27.16;	author D3Y133;	state Exp;
branches;
next	1.5;

1.5
date	2015.03.23.05.23.45;	author D3Y133;	state Exp;
branches;
next	1.4;

1.4
date	2015.01.03.09.46.43;	author D3Y133;	state Exp;
branches;
next	1.3;

1.3
date	2014.12.31.05.12.41;	author D3Y133;	state Exp;
branches;
next	1.2;

1.2
date	2014.11.30.08.22.46;	author D3Y133;	state Exp;
branches;
next	1.1;

1.1
date	2014.11.29.08.02.28;	author D3Y133;	state Exp;
branches;
next	;


desc
@Given an initial state and a gradient compute a new state
@


1.8
log
@Added the rotation of the row of the occupation functions to the update of 
the natural orbitals. The reason for this is that a rotation amongst the
natural orbitals changes the basis the occupation functions are expressed in.
For consistency we then need to update the occupation functions and express
them in the new basis.
@
text
@C> \ingroup wfn1_nxt2
C> @@{
C>
C> \brief Create a new state by moving one step from the old one
C> using matrix diagonalization
C>
C> The new state is generated from the old one by applying appropriate
C> rotations. The rotations are obtained from matrix diagonalization.
C>
      subroutine wfn1_nxt2_step_dg(nea,neb,nbf,it,statein,fock,grad,
     &                             stateout,levelshift)
      implicit none
c
#include "errquit.fh"
#include "mafdecls.fh"
#include "wfn1_nxt.fh"
c
      integer nea !< [Input] The number of alpha electrons
      integer neb !< [Input] The number of beta electrons
      integer nbf !< [Input] The number of basis functions
      integer it  !< [Input] The iteration number
c
      double precision statein(8*nbf*nbf+2*nbf) !< [Input] The initial state
      double precision fock(8*nbf*nbf+2*nbf)    !< [Input] The fock matrices
      double precision grad(8*nbf*nbf+2*nbf)    !< [Input] The gradient
c
      double precision stateout(8*nbf*nbf+2*nbf) !< [Input] The final state
c
      integer info  !< The status flag for DSYEV
      integer lwork !< The work space size for DSYEV
c
      integer l_m1,  k_m1
      integer l_m2,  k_m2
      integer l_exp, k_exp
      integer l_occa, k_occa
      integer l_occb, k_occb
      integer ir, ii
c
      double precision elow
      double precision ehigh
c
      double precision levelshift1
      double precision levelshift2
      double precision levelshift3
      double precision levelshift4
      double precision levelshift5
      parameter(levelshift1 = 4.0d0)
      parameter(levelshift2 = 2.0d0)
      parameter(levelshift3 = 1.0d0)
      parameter(levelshift4 = 0.5d0)
      parameter(levelshift5 = 1.0d-5)
c     parameter(levelshift5 = 1.0d-2)
      double precision levelshift !< [Input] The levelshifter
c
c     Allocate memory
c
      lwork = max(nbf*nbf,3*nbf)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"tmp1",l_m1,k_m1))
     &  call errquit("wfn1_nxt2_step: could not allocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,lwork,"tmp2",l_m2,k_m2))
     &  call errquit("wfn1_nxt2_step: could not allocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"exp",l_exp,k_exp))
     &  call errquit("wfn1_nxt2_step: could not allocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"occa",l_occa,k_occa))
     &  call errquit("wfn1_nxt2_step: could not allocate occa",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"occb",l_occb,k_occb))
     &  call errquit("wfn1_nxt2_step: could not allocate occb",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
c
c     Select the occupation function level shift
c
c     if (it.le.20) then
c       levelshift = levelshift1
c     else if (it.le.40) then
c       levelshift = levelshift2
c     else if (it.le.60) then
c       levelshift = levelshift3
c     else
c       levelshift = levelshift4
c     endif
c
c     Compute the occupation numbers
c
      call dfill(nbf,0.0d0,dbl_mb(k_occa),1)
      call dfill(nbf,0.0d0,dbl_mb(k_occb),1)
      do ir = 1, nbf
        do ii = 1, nbf
          dbl_mb(k_occa+ii-1) = dbl_mb(k_occa+ii-1)
     &       + statein(wfn1_nxt_aocc()+(ii-1)+nbf*(ir-1))**2
     &       * statein(wfn1_nxt_aconf()+ir-1)
          dbl_mb(k_occb+ii-1) = dbl_mb(k_occb+ii-1)
     &       + statein(wfn1_nxt_bocc()+(ii-1)+nbf*(ir-1))**2
     &       * statein(wfn1_nxt_bconf()+ir-1)
        enddo
      enddo

c
c     Alpha occupation functions
c
c     call wfn1_exp(nbf,grad(wfn1_nxt_aocc()),dbl_mb(k_m1),dbl_mb(k_m2),
c    &              dbl_mb(k_exp))
      call dcopy(nbf*nbf,fock(wfn1_nxt_aocc()),1,dbl_mb(k_exp),1)
cDEBUG
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_m1),levelshift,
     &                      statein(wfn1_nxt_aconf()))
cDEBUG
c     do ir = 2, nbf
c
c       Using a tiny levelshifter to fix the order of the degenerate
c       occupation functions
c
c       elow = dbl_mb(k_exp+(ir-2)+(ir-2)*nbf) + levelshift5
c       if (statein(wfn1_nxt_aconf()+(ir-1)).le.0.0d0) then
c         elow = elow + levelshift
c       endif
c       ehigh = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
c       dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) = max(elow,ehigh)
c     enddo
      info = 0 
c     lwork = nbf*nbf
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_step: dsyev failed a: ",info,UERR)
      endif
cDEBUG
c     write(*,*)"wfn1_nxt2_step: alpha occupation functions"
c     do ir = 1, nbf
c       write(*,*)'eig = ',ir,dbl_mb(k_m1-1+ir)
c     enddo
cDEBUG
c     call wfn1_nxt2_sort_columns(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_aocc()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c     call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_aocc()),nbf,
c    &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c
c     Beta occupation functions
c
c     call wfn1_exp(nbf,grad(wfn1_nxt_bocc()),dbl_mb(k_m1),dbl_mb(k_m2),
c    &              dbl_mb(k_exp))
      call dcopy(nbf*nbf,fock(wfn1_nxt_bocc()),1,dbl_mb(k_exp),1)
cDEBUG
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_m1),levelshift,
     &                      statein(wfn1_nxt_bconf()))
cDEBUG
c     do ir = 2, nbf
c
c       Using a tiny levelshifter to fix the order of the degenerate
c       occupation functions
c
c       elow = dbl_mb(k_exp+(ir-2)+(ir-2)*nbf) + levelshift5
c       if (statein(wfn1_nxt_bconf()+(ir-1)).le.0.0d0) then
c         elow = elow + levelshift
c       endif
c       ehigh = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
c       dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) = max(elow,ehigh)
c     enddo
      info = 0 
c     lwork = nbf*nbf
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_step: dsyev failed b: ",info,UERR)
      endif
cDEBUG
c     write(*,*)"wfn1_nxt2_step: beta occupation functions"
c     do ir = 1, nbf
c       write(*,*)'eig = ',ir,dbl_mb(k_m1-1+ir)
c     enddo
cDEBUG
c     call wfn1_nxt2_sort_columns(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bocc()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c     call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bocc()),nbf,
c    &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Alpha natural orbitals
c
c     call wfn1_exp(nbf,grad(wfn1_nxt_anat()),dbl_mb(k_m1),dbl_mb(k_m2),
c    &              dbl_mb(k_exp))
      call dcopy(nbf*nbf,fock(wfn1_nxt_anat()),1,dbl_mb(k_exp),1)
      call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
     &     statein(wfn1_nxt_anat()),stateout(wfn1_nxt_aocc()))
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
cDEBUG
c     call dscal(nbf,max(1.0d0,levelshift),dbl_mb(k_m1),1)
cDEBUG
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_m1),levelshift,
     &                      dbl_mb(k_occa))
      info = 0 
c     lwork = nbf*nbf
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_step: dsyev failed a: ",info,UERR)
      endif
cDEBUG
c     write(*,*)"wfn1_nxt2_step: alpha natural orbitals"
cDEBUG
c     call wfn1_nxt2_sort_columns(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_anat()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_anat()),nbf)
c     call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
c    &           statein(wfn1_nxt_aocc()),nbf,
c    &           0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c
c     Beta natural orbitals
c
c     call wfn1_exp(nbf,grad(wfn1_nxt_bnat()),dbl_mb(k_m1),dbl_mb(k_m2),
c    &              dbl_mb(k_exp))
      call dcopy(nbf*nbf,fock(wfn1_nxt_bnat()),1,dbl_mb(k_exp),1)
      call wfn1_nxt2_sort_diag(nbf,dbl_mb(k_exp),
     &     statein(wfn1_nxt_bnat()),stateout(wfn1_nxt_bocc()))
      call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
cDEBUG
c     call dscal(nbf,max(1.0d0,levelshift),dbl_mb(k_m1),1)
cDEBUG
      call wfn1_nxt2_lshift(nbf,dbl_mb(k_exp),dbl_mb(k_m1),levelshift,
     &                      dbl_mb(k_occb))
      info = 0 
c     lwork = nbf*nbf
      call dsyev('v','u',nbf,dbl_mb(k_exp),nbf,dbl_mb(k_m1),
     &           dbl_mb(k_m2),lwork,info)
      if (info.ne.0) then
        call errquit("wfn1_nxt2_step: dsyev failed b: ",info,UERR)
      endif
cDEBUG
c     write(*,*)"wfn1_nxt2_step: beta natural orbitals"
cDEBUG
c     call wfn1_nxt2_sort_columns(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bnat()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bnat()),nbf)
c     call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
c    &           statein(wfn1_nxt_bocc()),nbf,
c    &           0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Copy the electron configurations
c
      call dcopy(nbf,statein(wfn1_nxt_aconf()),1,
     &               stateout(wfn1_nxt_aconf()),1)
      call dcopy(nbf,statein(wfn1_nxt_bconf()),1,
     &               stateout(wfn1_nxt_bconf()),1)
c
c     Cleanup memory
c
      if (.not.ma_pop_stack(l_occb))
     &  call errquit("wfn1_nxt2_step: could not deallocate occb",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_occa))
     &  call errquit("wfn1_nxt2_step: could not deallocate occa",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_exp))
     &  call errquit("wfn1_nxt2_step: could not deallocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m2))
     &  call errquit("wfn1_nxt2_step: could not deallocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m1))
     &  call errquit("wfn1_nxt2_step: could not deallocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      end
C>
C> \brief Create a new state by moving one step from the old one
C> using matrix exponents 
C>
C> The new state is generated from the old one by applying appropriate
C> rotations. The rotations are obtained from calculating the
C> exponent of the gradient matrix. This approach is used with 
C> linesearches (ls) hence the name.
C>
      subroutine wfn1_nxt2_step_ls(nea,neb,nbf,it,statein,fock,grad,
     &                             stateout,levelshift)
      implicit none
c
#include "errquit.fh"
#include "mafdecls.fh"
#include "wfn1_nxt.fh"
c
      integer nea !< [Input] The number of alpha electrons
      integer neb !< [Input] The number of beta electrons
      integer nbf !< [Input] The number of basis functions
      integer it  !< [Input] The iteration number
c
      double precision statein(8*nbf*nbf+2*nbf) !< [Input] The initial state
      double precision fock(8*nbf*nbf+2*nbf)    !< [Input] The fock matrices
      double precision grad(8*nbf*nbf+2*nbf)    !< [Input] The gradient
c
      double precision stateout(8*nbf*nbf+2*nbf) !< [Input] The final state
c
      integer info  !< The status flag for DSYEV
      integer lwork !< The work space size for DSYEV
c
      integer l_m1,  k_m1
      integer l_m2,  k_m2
      integer l_exp, k_exp
      integer l_occa, k_occa
      integer l_occb, k_occb
      integer ir, ii
c
      double precision elow
      double precision ehigh
c
      double precision levelshift !< [Input] The levelshifter
c
c     Allocate memory
c
      lwork = max(nbf*nbf,3*nbf)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"tmp1",l_m1,k_m1))
     &  call errquit("wfn1_nxt2_step: could not allocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,lwork,"tmp2",l_m2,k_m2))
     &  call errquit("wfn1_nxt2_step: could not allocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"exp",l_exp,k_exp))
     &  call errquit("wfn1_nxt2_step: could not allocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"occa",l_occa,k_occa))
     &  call errquit("wfn1_nxt2_step: could not allocate occa",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
      if (.not.ma_push_get(MT_DBL,nbf,"occb",l_occb,k_occb))
     &  call errquit("wfn1_nxt2_step: could not allocate occb",
     &  ma_sizeof(MT_DBL,nbf,MT_BYTE),MA_ERR)
c
c     Compute the occupation numbers
c
c     call dfill(nbf,0.0d0,dbl_mb(k_occa),1)
c     call dfill(nbf,0.0d0,dbl_mb(k_occb),1)
c     do ir = 1, nbf
c       do ii = 1, nbf
c         dbl_mb(k_occa+ii-1) = dbl_mb(k_occa+ii-1)
c    &       + statein(wfn1_nxt_aocc()+(ii-1)+nbf*(ir-1))**2
c    &       * statein(wfn1_nxt_aconf()+ir-1)
c         dbl_mb(k_occb+ii-1) = dbl_mb(k_occb+ii-1)
c    &       + statein(wfn1_nxt_bocc()+(ii-1)+nbf*(ir-1))**2
c    &       * statein(wfn1_nxt_bconf()+ir-1)
c       enddo
c     enddo
c
c     Alpha occupation functions
c
      call wfn1_exp(nbf,grad(wfn1_nxt_aocc()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_aocc()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
c
c     Beta occupation functions
c
      call wfn1_exp(nbf,grad(wfn1_nxt_bocc()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bocc()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
c
c     Alpha natural orbitals
c
      call wfn1_exp(nbf,grad(wfn1_nxt_anat()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_anat()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_anat()),nbf)
cDEBUG
c     also rotate the rows in the occupation functions
      call dcopy(nbf*nbf,stateout(wfn1_nxt_aocc()),1,dbl_mb(k_m2),1)
      call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
     &           dbl_mb(k_m2),nbf,0.0d0,stateout(wfn1_nxt_aocc()),nbf)
cDEBUG
c
c     Beta natural orbitals
c
      call wfn1_exp(nbf,grad(wfn1_nxt_bnat()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
      call dgemm('n','n',nbf,nbf,nbf,1.0d0,statein(wfn1_nxt_bnat()),nbf,
     &           dbl_mb(k_exp),nbf,0.0d0,stateout(wfn1_nxt_bnat()),nbf)
cDEBUG
c     also rotate the rows in the occupation functions
      call dcopy(nbf*nbf,stateout(wfn1_nxt_bocc()),1,dbl_mb(k_m2),1)
      call dgemm('t','n',nbf,nbf,nbf,1.0d0,dbl_mb(k_exp),nbf,
     &           dbl_mb(k_m2),nbf,0.0d0,stateout(wfn1_nxt_bocc()),nbf)
cDEBUG
c
c     Copy the electron configurations
c
      call dcopy(nbf,statein(wfn1_nxt_aconf()),1,
     &               stateout(wfn1_nxt_aconf()),1)
      call dcopy(nbf,statein(wfn1_nxt_bconf()),1,
     &               stateout(wfn1_nxt_bconf()),1)
c
c     Cleanup memory
c
      if (.not.ma_pop_stack(l_occb))
     &  call errquit("wfn1_nxt2_step: could not deallocate occb",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_occa))
     &  call errquit("wfn1_nxt2_step: could not deallocate occa",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_exp))
     &  call errquit("wfn1_nxt2_step: could not deallocate exp",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m2))
     &  call errquit("wfn1_nxt2_step: could not deallocate tmp2",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
      if (.not.ma_pop_stack(l_m1))
     &  call errquit("wfn1_nxt2_step: could not deallocate tmp1",
     &  ma_sizeof(MT_DBL,nbf*nbf,MT_BYTE),MA_ERR)
c
      end
C> @@}
@


1.7
log
@Now there are two step routines. One for a diagonalization based
approach, and another one for a linesearch based approach.
@
text
@d367 6
d380 6
@


1.6
log
@Added using more advanced level shifters to damp the orbital rotations.
This got Helium to work in the 6-31G basis.
@
text
@d5 1
d8 1
a8 1
C> rotations.
d10 2
a11 2
      subroutine wfn1_nxt2_step(nea,neb,nbf,it,statein,fock,grad,
     &                          stateout,levelshift)
d243 131
@


1.5
log
@Added some damping methods based on Gershgorin disks.
@
text
@d10 1
a10 1
     &                          stateout)
d34 3
a36 1
      integer ir
d52 1
a52 1
      double precision levelshift
d66 6
d75 25
a99 9
      if (it.le.20) then
        levelshift = levelshift1
      else if (it.le.40) then
        levelshift = levelshift2
      else if (it.le.60) then
        levelshift = levelshift3
      else
        levelshift = levelshift4
      endif
d107 3
a109 2
c     call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
c     call wfn1_nxt2_shift(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
d111 1
a111 1
      do ir = 2, nbf
d116 7
a122 7
        elow = dbl_mb(k_exp+(ir-2)+(ir-2)*nbf) + levelshift5
        if (statein(wfn1_nxt_aconf()+(ir-1)).le.0.0d0) then
          elow = elow + levelshift
        endif
        ehigh = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
        dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) = max(elow,ehigh)
      enddo
d148 3
a150 2
c     call wfn1_nxt2_gershgorin(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
c     call wfn1_nxt2_shift(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
d152 1
a152 1
      do ir = 2, nbf
d157 7
a163 7
        elow = dbl_mb(k_exp+(ir-2)+(ir-2)*nbf) + levelshift5
        if (statein(wfn1_nxt_bconf()+(ir-1)).le.0.0d0) then
          elow = elow + levelshift
        endif
        ehigh = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
        dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) = max(elow,ehigh)
      enddo
d194 2
a195 1
      call wfn1_nxt2_shift(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
d224 2
a225 1
      call wfn1_nxt2_shift(nbf,dbl_mb(k_exp),dbl_mb(k_m1))
d252 6
@


1.4
log
@Make the energy minimization converge with repeated diagonalization
and levelshifting of the occupation function Fock matrix.
@
text
@d22 3
a24 3
      double precision statein(8*nbf*nbf) !< [Input] The initial state
      double precision fock(8*nbf*nbf)    !< [Input] The fock matrices
      double precision grad(8*nbf*nbf)    !< [Input] The gradient
d26 1
a26 1
      double precision stateout(8*nbf*nbf) !< [Input] The final state
d36 3
d43 4
a46 3
      parameter(levelshift1 = 2.0d0)
      parameter(levelshift2 = 1.0d0)
      parameter(levelshift3 = 0.5d0)
d48 2
d54 1
d58 1
a58 1
      if (.not.ma_push_get(MT_DBL,nbf*nbf,"tmp2",l_m2,k_m2))
d82 15
a96 3
      do ir = nea+1, nbf
        dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
     &     = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) + levelshift
d99 1
a99 1
      lwork = nbf*nbf
d107 3
d122 15
a136 3
      do ir = neb+1, nbf
        dbl_mb(k_exp+(ir-1)+(ir-1)*nbf)
     &     = dbl_mb(k_exp+(ir-1)+(ir-1)*nbf) + levelshift
d139 1
a139 1
      lwork = nbf*nbf
d147 3
d162 7
d170 1
a170 1
      lwork = nbf*nbf
d191 7
d199 1
a199 1
      lwork = nbf*nbf
d214 7
@


1.3
log
@Now deal with the rotation of the natural orbitals through a 
Fock matrix diagonalization.
@
text
@d9 2
a10 1
      subroutine wfn1_nxt2_step(nbf,statein,fock,grad,stateout)
d17 2
d20 1
d34 11
d58 12
d72 18
a89 2
      call wfn1_exp(nbf,grad(wfn1_nxt_aocc()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
d92 2
d97 18
a114 2
      call wfn1_exp(nbf,grad(wfn1_nxt_bocc()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
d117 2
d132 4
d154 4
@


1.2
log
@fixing_type_declarations
@
text
@d9 1
a9 1
      subroutine wfn1_nxt2_step(nbf,statein,grad,stateout)
d19 1
d24 3
d59 10
a68 2
      call wfn1_exp(nbf,grad(wfn1_nxt_anat()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
d71 3
d77 10
a86 2
      call wfn1_exp(nbf,grad(wfn1_nxt_bnat()),dbl_mb(k_m1),dbl_mb(k_m2),
     &              dbl_mb(k_exp))
d89 3
@


1.1
log
@Initial revision
@
text
@d12 1
d14 1
@
